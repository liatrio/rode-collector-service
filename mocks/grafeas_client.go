// Code generated by counterfeiter. DO NOT EDIT.
package mocks

import (
	"context"
	"sync"

	"github.com/rode/rode/protodeps/grafeas/proto/v1beta1/grafeas_go_proto"
	"google.golang.org/grpc"
	"google.golang.org/protobuf/types/known/emptypb"
)

type FakeGrafeasV1Beta1Client struct {
	BatchCreateNotesStub        func(context.Context, *grafeas_go_proto.BatchCreateNotesRequest, ...grpc.CallOption) (*grafeas_go_proto.BatchCreateNotesResponse, error)
	batchCreateNotesMutex       sync.RWMutex
	batchCreateNotesArgsForCall []struct {
		arg1 context.Context
		arg2 *grafeas_go_proto.BatchCreateNotesRequest
		arg3 []grpc.CallOption
	}
	batchCreateNotesReturns struct {
		result1 *grafeas_go_proto.BatchCreateNotesResponse
		result2 error
	}
	batchCreateNotesReturnsOnCall map[int]struct {
		result1 *grafeas_go_proto.BatchCreateNotesResponse
		result2 error
	}
	BatchCreateOccurrencesStub        func(context.Context, *grafeas_go_proto.BatchCreateOccurrencesRequest, ...grpc.CallOption) (*grafeas_go_proto.BatchCreateOccurrencesResponse, error)
	batchCreateOccurrencesMutex       sync.RWMutex
	batchCreateOccurrencesArgsForCall []struct {
		arg1 context.Context
		arg2 *grafeas_go_proto.BatchCreateOccurrencesRequest
		arg3 []grpc.CallOption
	}
	batchCreateOccurrencesReturns struct {
		result1 *grafeas_go_proto.BatchCreateOccurrencesResponse
		result2 error
	}
	batchCreateOccurrencesReturnsOnCall map[int]struct {
		result1 *grafeas_go_proto.BatchCreateOccurrencesResponse
		result2 error
	}
	CreateNoteStub        func(context.Context, *grafeas_go_proto.CreateNoteRequest, ...grpc.CallOption) (*grafeas_go_proto.Note, error)
	createNoteMutex       sync.RWMutex
	createNoteArgsForCall []struct {
		arg1 context.Context
		arg2 *grafeas_go_proto.CreateNoteRequest
		arg3 []grpc.CallOption
	}
	createNoteReturns struct {
		result1 *grafeas_go_proto.Note
		result2 error
	}
	createNoteReturnsOnCall map[int]struct {
		result1 *grafeas_go_proto.Note
		result2 error
	}
	CreateOccurrenceStub        func(context.Context, *grafeas_go_proto.CreateOccurrenceRequest, ...grpc.CallOption) (*grafeas_go_proto.Occurrence, error)
	createOccurrenceMutex       sync.RWMutex
	createOccurrenceArgsForCall []struct {
		arg1 context.Context
		arg2 *grafeas_go_proto.CreateOccurrenceRequest
		arg3 []grpc.CallOption
	}
	createOccurrenceReturns struct {
		result1 *grafeas_go_proto.Occurrence
		result2 error
	}
	createOccurrenceReturnsOnCall map[int]struct {
		result1 *grafeas_go_proto.Occurrence
		result2 error
	}
	DeleteNoteStub        func(context.Context, *grafeas_go_proto.DeleteNoteRequest, ...grpc.CallOption) (*emptypb.Empty, error)
	deleteNoteMutex       sync.RWMutex
	deleteNoteArgsForCall []struct {
		arg1 context.Context
		arg2 *grafeas_go_proto.DeleteNoteRequest
		arg3 []grpc.CallOption
	}
	deleteNoteReturns struct {
		result1 *emptypb.Empty
		result2 error
	}
	deleteNoteReturnsOnCall map[int]struct {
		result1 *emptypb.Empty
		result2 error
	}
	DeleteOccurrenceStub        func(context.Context, *grafeas_go_proto.DeleteOccurrenceRequest, ...grpc.CallOption) (*emptypb.Empty, error)
	deleteOccurrenceMutex       sync.RWMutex
	deleteOccurrenceArgsForCall []struct {
		arg1 context.Context
		arg2 *grafeas_go_proto.DeleteOccurrenceRequest
		arg3 []grpc.CallOption
	}
	deleteOccurrenceReturns struct {
		result1 *emptypb.Empty
		result2 error
	}
	deleteOccurrenceReturnsOnCall map[int]struct {
		result1 *emptypb.Empty
		result2 error
	}
	GetNoteStub        func(context.Context, *grafeas_go_proto.GetNoteRequest, ...grpc.CallOption) (*grafeas_go_proto.Note, error)
	getNoteMutex       sync.RWMutex
	getNoteArgsForCall []struct {
		arg1 context.Context
		arg2 *grafeas_go_proto.GetNoteRequest
		arg3 []grpc.CallOption
	}
	getNoteReturns struct {
		result1 *grafeas_go_proto.Note
		result2 error
	}
	getNoteReturnsOnCall map[int]struct {
		result1 *grafeas_go_proto.Note
		result2 error
	}
	GetOccurrenceStub        func(context.Context, *grafeas_go_proto.GetOccurrenceRequest, ...grpc.CallOption) (*grafeas_go_proto.Occurrence, error)
	getOccurrenceMutex       sync.RWMutex
	getOccurrenceArgsForCall []struct {
		arg1 context.Context
		arg2 *grafeas_go_proto.GetOccurrenceRequest
		arg3 []grpc.CallOption
	}
	getOccurrenceReturns struct {
		result1 *grafeas_go_proto.Occurrence
		result2 error
	}
	getOccurrenceReturnsOnCall map[int]struct {
		result1 *grafeas_go_proto.Occurrence
		result2 error
	}
	GetOccurrenceNoteStub        func(context.Context, *grafeas_go_proto.GetOccurrenceNoteRequest, ...grpc.CallOption) (*grafeas_go_proto.Note, error)
	getOccurrenceNoteMutex       sync.RWMutex
	getOccurrenceNoteArgsForCall []struct {
		arg1 context.Context
		arg2 *grafeas_go_proto.GetOccurrenceNoteRequest
		arg3 []grpc.CallOption
	}
	getOccurrenceNoteReturns struct {
		result1 *grafeas_go_proto.Note
		result2 error
	}
	getOccurrenceNoteReturnsOnCall map[int]struct {
		result1 *grafeas_go_proto.Note
		result2 error
	}
	GetVulnerabilityOccurrencesSummaryStub        func(context.Context, *grafeas_go_proto.GetVulnerabilityOccurrencesSummaryRequest, ...grpc.CallOption) (*grafeas_go_proto.VulnerabilityOccurrencesSummary, error)
	getVulnerabilityOccurrencesSummaryMutex       sync.RWMutex
	getVulnerabilityOccurrencesSummaryArgsForCall []struct {
		arg1 context.Context
		arg2 *grafeas_go_proto.GetVulnerabilityOccurrencesSummaryRequest
		arg3 []grpc.CallOption
	}
	getVulnerabilityOccurrencesSummaryReturns struct {
		result1 *grafeas_go_proto.VulnerabilityOccurrencesSummary
		result2 error
	}
	getVulnerabilityOccurrencesSummaryReturnsOnCall map[int]struct {
		result1 *grafeas_go_proto.VulnerabilityOccurrencesSummary
		result2 error
	}
	ListNoteOccurrencesStub        func(context.Context, *grafeas_go_proto.ListNoteOccurrencesRequest, ...grpc.CallOption) (*grafeas_go_proto.ListNoteOccurrencesResponse, error)
	listNoteOccurrencesMutex       sync.RWMutex
	listNoteOccurrencesArgsForCall []struct {
		arg1 context.Context
		arg2 *grafeas_go_proto.ListNoteOccurrencesRequest
		arg3 []grpc.CallOption
	}
	listNoteOccurrencesReturns struct {
		result1 *grafeas_go_proto.ListNoteOccurrencesResponse
		result2 error
	}
	listNoteOccurrencesReturnsOnCall map[int]struct {
		result1 *grafeas_go_proto.ListNoteOccurrencesResponse
		result2 error
	}
	ListNotesStub        func(context.Context, *grafeas_go_proto.ListNotesRequest, ...grpc.CallOption) (*grafeas_go_proto.ListNotesResponse, error)
	listNotesMutex       sync.RWMutex
	listNotesArgsForCall []struct {
		arg1 context.Context
		arg2 *grafeas_go_proto.ListNotesRequest
		arg3 []grpc.CallOption
	}
	listNotesReturns struct {
		result1 *grafeas_go_proto.ListNotesResponse
		result2 error
	}
	listNotesReturnsOnCall map[int]struct {
		result1 *grafeas_go_proto.ListNotesResponse
		result2 error
	}
	ListOccurrencesStub        func(context.Context, *grafeas_go_proto.ListOccurrencesRequest, ...grpc.CallOption) (*grafeas_go_proto.ListOccurrencesResponse, error)
	listOccurrencesMutex       sync.RWMutex
	listOccurrencesArgsForCall []struct {
		arg1 context.Context
		arg2 *grafeas_go_proto.ListOccurrencesRequest
		arg3 []grpc.CallOption
	}
	listOccurrencesReturns struct {
		result1 *grafeas_go_proto.ListOccurrencesResponse
		result2 error
	}
	listOccurrencesReturnsOnCall map[int]struct {
		result1 *grafeas_go_proto.ListOccurrencesResponse
		result2 error
	}
	UpdateNoteStub        func(context.Context, *grafeas_go_proto.UpdateNoteRequest, ...grpc.CallOption) (*grafeas_go_proto.Note, error)
	updateNoteMutex       sync.RWMutex
	updateNoteArgsForCall []struct {
		arg1 context.Context
		arg2 *grafeas_go_proto.UpdateNoteRequest
		arg3 []grpc.CallOption
	}
	updateNoteReturns struct {
		result1 *grafeas_go_proto.Note
		result2 error
	}
	updateNoteReturnsOnCall map[int]struct {
		result1 *grafeas_go_proto.Note
		result2 error
	}
	UpdateOccurrenceStub        func(context.Context, *grafeas_go_proto.UpdateOccurrenceRequest, ...grpc.CallOption) (*grafeas_go_proto.Occurrence, error)
	updateOccurrenceMutex       sync.RWMutex
	updateOccurrenceArgsForCall []struct {
		arg1 context.Context
		arg2 *grafeas_go_proto.UpdateOccurrenceRequest
		arg3 []grpc.CallOption
	}
	updateOccurrenceReturns struct {
		result1 *grafeas_go_proto.Occurrence
		result2 error
	}
	updateOccurrenceReturnsOnCall map[int]struct {
		result1 *grafeas_go_proto.Occurrence
		result2 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeGrafeasV1Beta1Client) BatchCreateNotes(arg1 context.Context, arg2 *grafeas_go_proto.BatchCreateNotesRequest, arg3 ...grpc.CallOption) (*grafeas_go_proto.BatchCreateNotesResponse, error) {
	fake.batchCreateNotesMutex.Lock()
	ret, specificReturn := fake.batchCreateNotesReturnsOnCall[len(fake.batchCreateNotesArgsForCall)]
	fake.batchCreateNotesArgsForCall = append(fake.batchCreateNotesArgsForCall, struct {
		arg1 context.Context
		arg2 *grafeas_go_proto.BatchCreateNotesRequest
		arg3 []grpc.CallOption
	}{arg1, arg2, arg3})
	stub := fake.BatchCreateNotesStub
	fakeReturns := fake.batchCreateNotesReturns
	fake.recordInvocation("BatchCreateNotes", []interface{}{arg1, arg2, arg3})
	fake.batchCreateNotesMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeGrafeasV1Beta1Client) BatchCreateNotesCallCount() int {
	fake.batchCreateNotesMutex.RLock()
	defer fake.batchCreateNotesMutex.RUnlock()
	return len(fake.batchCreateNotesArgsForCall)
}

func (fake *FakeGrafeasV1Beta1Client) BatchCreateNotesCalls(stub func(context.Context, *grafeas_go_proto.BatchCreateNotesRequest, ...grpc.CallOption) (*grafeas_go_proto.BatchCreateNotesResponse, error)) {
	fake.batchCreateNotesMutex.Lock()
	defer fake.batchCreateNotesMutex.Unlock()
	fake.BatchCreateNotesStub = stub
}

func (fake *FakeGrafeasV1Beta1Client) BatchCreateNotesArgsForCall(i int) (context.Context, *grafeas_go_proto.BatchCreateNotesRequest, []grpc.CallOption) {
	fake.batchCreateNotesMutex.RLock()
	defer fake.batchCreateNotesMutex.RUnlock()
	argsForCall := fake.batchCreateNotesArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeGrafeasV1Beta1Client) BatchCreateNotesReturns(result1 *grafeas_go_proto.BatchCreateNotesResponse, result2 error) {
	fake.batchCreateNotesMutex.Lock()
	defer fake.batchCreateNotesMutex.Unlock()
	fake.BatchCreateNotesStub = nil
	fake.batchCreateNotesReturns = struct {
		result1 *grafeas_go_proto.BatchCreateNotesResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeGrafeasV1Beta1Client) BatchCreateNotesReturnsOnCall(i int, result1 *grafeas_go_proto.BatchCreateNotesResponse, result2 error) {
	fake.batchCreateNotesMutex.Lock()
	defer fake.batchCreateNotesMutex.Unlock()
	fake.BatchCreateNotesStub = nil
	if fake.batchCreateNotesReturnsOnCall == nil {
		fake.batchCreateNotesReturnsOnCall = make(map[int]struct {
			result1 *grafeas_go_proto.BatchCreateNotesResponse
			result2 error
		})
	}
	fake.batchCreateNotesReturnsOnCall[i] = struct {
		result1 *grafeas_go_proto.BatchCreateNotesResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeGrafeasV1Beta1Client) BatchCreateOccurrences(arg1 context.Context, arg2 *grafeas_go_proto.BatchCreateOccurrencesRequest, arg3 ...grpc.CallOption) (*grafeas_go_proto.BatchCreateOccurrencesResponse, error) {
	fake.batchCreateOccurrencesMutex.Lock()
	ret, specificReturn := fake.batchCreateOccurrencesReturnsOnCall[len(fake.batchCreateOccurrencesArgsForCall)]
	fake.batchCreateOccurrencesArgsForCall = append(fake.batchCreateOccurrencesArgsForCall, struct {
		arg1 context.Context
		arg2 *grafeas_go_proto.BatchCreateOccurrencesRequest
		arg3 []grpc.CallOption
	}{arg1, arg2, arg3})
	stub := fake.BatchCreateOccurrencesStub
	fakeReturns := fake.batchCreateOccurrencesReturns
	fake.recordInvocation("BatchCreateOccurrences", []interface{}{arg1, arg2, arg3})
	fake.batchCreateOccurrencesMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeGrafeasV1Beta1Client) BatchCreateOccurrencesCallCount() int {
	fake.batchCreateOccurrencesMutex.RLock()
	defer fake.batchCreateOccurrencesMutex.RUnlock()
	return len(fake.batchCreateOccurrencesArgsForCall)
}

func (fake *FakeGrafeasV1Beta1Client) BatchCreateOccurrencesCalls(stub func(context.Context, *grafeas_go_proto.BatchCreateOccurrencesRequest, ...grpc.CallOption) (*grafeas_go_proto.BatchCreateOccurrencesResponse, error)) {
	fake.batchCreateOccurrencesMutex.Lock()
	defer fake.batchCreateOccurrencesMutex.Unlock()
	fake.BatchCreateOccurrencesStub = stub
}

func (fake *FakeGrafeasV1Beta1Client) BatchCreateOccurrencesArgsForCall(i int) (context.Context, *grafeas_go_proto.BatchCreateOccurrencesRequest, []grpc.CallOption) {
	fake.batchCreateOccurrencesMutex.RLock()
	defer fake.batchCreateOccurrencesMutex.RUnlock()
	argsForCall := fake.batchCreateOccurrencesArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeGrafeasV1Beta1Client) BatchCreateOccurrencesReturns(result1 *grafeas_go_proto.BatchCreateOccurrencesResponse, result2 error) {
	fake.batchCreateOccurrencesMutex.Lock()
	defer fake.batchCreateOccurrencesMutex.Unlock()
	fake.BatchCreateOccurrencesStub = nil
	fake.batchCreateOccurrencesReturns = struct {
		result1 *grafeas_go_proto.BatchCreateOccurrencesResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeGrafeasV1Beta1Client) BatchCreateOccurrencesReturnsOnCall(i int, result1 *grafeas_go_proto.BatchCreateOccurrencesResponse, result2 error) {
	fake.batchCreateOccurrencesMutex.Lock()
	defer fake.batchCreateOccurrencesMutex.Unlock()
	fake.BatchCreateOccurrencesStub = nil
	if fake.batchCreateOccurrencesReturnsOnCall == nil {
		fake.batchCreateOccurrencesReturnsOnCall = make(map[int]struct {
			result1 *grafeas_go_proto.BatchCreateOccurrencesResponse
			result2 error
		})
	}
	fake.batchCreateOccurrencesReturnsOnCall[i] = struct {
		result1 *grafeas_go_proto.BatchCreateOccurrencesResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeGrafeasV1Beta1Client) CreateNote(arg1 context.Context, arg2 *grafeas_go_proto.CreateNoteRequest, arg3 ...grpc.CallOption) (*grafeas_go_proto.Note, error) {
	fake.createNoteMutex.Lock()
	ret, specificReturn := fake.createNoteReturnsOnCall[len(fake.createNoteArgsForCall)]
	fake.createNoteArgsForCall = append(fake.createNoteArgsForCall, struct {
		arg1 context.Context
		arg2 *grafeas_go_proto.CreateNoteRequest
		arg3 []grpc.CallOption
	}{arg1, arg2, arg3})
	stub := fake.CreateNoteStub
	fakeReturns := fake.createNoteReturns
	fake.recordInvocation("CreateNote", []interface{}{arg1, arg2, arg3})
	fake.createNoteMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeGrafeasV1Beta1Client) CreateNoteCallCount() int {
	fake.createNoteMutex.RLock()
	defer fake.createNoteMutex.RUnlock()
	return len(fake.createNoteArgsForCall)
}

func (fake *FakeGrafeasV1Beta1Client) CreateNoteCalls(stub func(context.Context, *grafeas_go_proto.CreateNoteRequest, ...grpc.CallOption) (*grafeas_go_proto.Note, error)) {
	fake.createNoteMutex.Lock()
	defer fake.createNoteMutex.Unlock()
	fake.CreateNoteStub = stub
}

func (fake *FakeGrafeasV1Beta1Client) CreateNoteArgsForCall(i int) (context.Context, *grafeas_go_proto.CreateNoteRequest, []grpc.CallOption) {
	fake.createNoteMutex.RLock()
	defer fake.createNoteMutex.RUnlock()
	argsForCall := fake.createNoteArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeGrafeasV1Beta1Client) CreateNoteReturns(result1 *grafeas_go_proto.Note, result2 error) {
	fake.createNoteMutex.Lock()
	defer fake.createNoteMutex.Unlock()
	fake.CreateNoteStub = nil
	fake.createNoteReturns = struct {
		result1 *grafeas_go_proto.Note
		result2 error
	}{result1, result2}
}

func (fake *FakeGrafeasV1Beta1Client) CreateNoteReturnsOnCall(i int, result1 *grafeas_go_proto.Note, result2 error) {
	fake.createNoteMutex.Lock()
	defer fake.createNoteMutex.Unlock()
	fake.CreateNoteStub = nil
	if fake.createNoteReturnsOnCall == nil {
		fake.createNoteReturnsOnCall = make(map[int]struct {
			result1 *grafeas_go_proto.Note
			result2 error
		})
	}
	fake.createNoteReturnsOnCall[i] = struct {
		result1 *grafeas_go_proto.Note
		result2 error
	}{result1, result2}
}

func (fake *FakeGrafeasV1Beta1Client) CreateOccurrence(arg1 context.Context, arg2 *grafeas_go_proto.CreateOccurrenceRequest, arg3 ...grpc.CallOption) (*grafeas_go_proto.Occurrence, error) {
	fake.createOccurrenceMutex.Lock()
	ret, specificReturn := fake.createOccurrenceReturnsOnCall[len(fake.createOccurrenceArgsForCall)]
	fake.createOccurrenceArgsForCall = append(fake.createOccurrenceArgsForCall, struct {
		arg1 context.Context
		arg2 *grafeas_go_proto.CreateOccurrenceRequest
		arg3 []grpc.CallOption
	}{arg1, arg2, arg3})
	stub := fake.CreateOccurrenceStub
	fakeReturns := fake.createOccurrenceReturns
	fake.recordInvocation("CreateOccurrence", []interface{}{arg1, arg2, arg3})
	fake.createOccurrenceMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeGrafeasV1Beta1Client) CreateOccurrenceCallCount() int {
	fake.createOccurrenceMutex.RLock()
	defer fake.createOccurrenceMutex.RUnlock()
	return len(fake.createOccurrenceArgsForCall)
}

func (fake *FakeGrafeasV1Beta1Client) CreateOccurrenceCalls(stub func(context.Context, *grafeas_go_proto.CreateOccurrenceRequest, ...grpc.CallOption) (*grafeas_go_proto.Occurrence, error)) {
	fake.createOccurrenceMutex.Lock()
	defer fake.createOccurrenceMutex.Unlock()
	fake.CreateOccurrenceStub = stub
}

func (fake *FakeGrafeasV1Beta1Client) CreateOccurrenceArgsForCall(i int) (context.Context, *grafeas_go_proto.CreateOccurrenceRequest, []grpc.CallOption) {
	fake.createOccurrenceMutex.RLock()
	defer fake.createOccurrenceMutex.RUnlock()
	argsForCall := fake.createOccurrenceArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeGrafeasV1Beta1Client) CreateOccurrenceReturns(result1 *grafeas_go_proto.Occurrence, result2 error) {
	fake.createOccurrenceMutex.Lock()
	defer fake.createOccurrenceMutex.Unlock()
	fake.CreateOccurrenceStub = nil
	fake.createOccurrenceReturns = struct {
		result1 *grafeas_go_proto.Occurrence
		result2 error
	}{result1, result2}
}

func (fake *FakeGrafeasV1Beta1Client) CreateOccurrenceReturnsOnCall(i int, result1 *grafeas_go_proto.Occurrence, result2 error) {
	fake.createOccurrenceMutex.Lock()
	defer fake.createOccurrenceMutex.Unlock()
	fake.CreateOccurrenceStub = nil
	if fake.createOccurrenceReturnsOnCall == nil {
		fake.createOccurrenceReturnsOnCall = make(map[int]struct {
			result1 *grafeas_go_proto.Occurrence
			result2 error
		})
	}
	fake.createOccurrenceReturnsOnCall[i] = struct {
		result1 *grafeas_go_proto.Occurrence
		result2 error
	}{result1, result2}
}

func (fake *FakeGrafeasV1Beta1Client) DeleteNote(arg1 context.Context, arg2 *grafeas_go_proto.DeleteNoteRequest, arg3 ...grpc.CallOption) (*emptypb.Empty, error) {
	fake.deleteNoteMutex.Lock()
	ret, specificReturn := fake.deleteNoteReturnsOnCall[len(fake.deleteNoteArgsForCall)]
	fake.deleteNoteArgsForCall = append(fake.deleteNoteArgsForCall, struct {
		arg1 context.Context
		arg2 *grafeas_go_proto.DeleteNoteRequest
		arg3 []grpc.CallOption
	}{arg1, arg2, arg3})
	stub := fake.DeleteNoteStub
	fakeReturns := fake.deleteNoteReturns
	fake.recordInvocation("DeleteNote", []interface{}{arg1, arg2, arg3})
	fake.deleteNoteMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeGrafeasV1Beta1Client) DeleteNoteCallCount() int {
	fake.deleteNoteMutex.RLock()
	defer fake.deleteNoteMutex.RUnlock()
	return len(fake.deleteNoteArgsForCall)
}

func (fake *FakeGrafeasV1Beta1Client) DeleteNoteCalls(stub func(context.Context, *grafeas_go_proto.DeleteNoteRequest, ...grpc.CallOption) (*emptypb.Empty, error)) {
	fake.deleteNoteMutex.Lock()
	defer fake.deleteNoteMutex.Unlock()
	fake.DeleteNoteStub = stub
}

func (fake *FakeGrafeasV1Beta1Client) DeleteNoteArgsForCall(i int) (context.Context, *grafeas_go_proto.DeleteNoteRequest, []grpc.CallOption) {
	fake.deleteNoteMutex.RLock()
	defer fake.deleteNoteMutex.RUnlock()
	argsForCall := fake.deleteNoteArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeGrafeasV1Beta1Client) DeleteNoteReturns(result1 *emptypb.Empty, result2 error) {
	fake.deleteNoteMutex.Lock()
	defer fake.deleteNoteMutex.Unlock()
	fake.DeleteNoteStub = nil
	fake.deleteNoteReturns = struct {
		result1 *emptypb.Empty
		result2 error
	}{result1, result2}
}

func (fake *FakeGrafeasV1Beta1Client) DeleteNoteReturnsOnCall(i int, result1 *emptypb.Empty, result2 error) {
	fake.deleteNoteMutex.Lock()
	defer fake.deleteNoteMutex.Unlock()
	fake.DeleteNoteStub = nil
	if fake.deleteNoteReturnsOnCall == nil {
		fake.deleteNoteReturnsOnCall = make(map[int]struct {
			result1 *emptypb.Empty
			result2 error
		})
	}
	fake.deleteNoteReturnsOnCall[i] = struct {
		result1 *emptypb.Empty
		result2 error
	}{result1, result2}
}

func (fake *FakeGrafeasV1Beta1Client) DeleteOccurrence(arg1 context.Context, arg2 *grafeas_go_proto.DeleteOccurrenceRequest, arg3 ...grpc.CallOption) (*emptypb.Empty, error) {
	fake.deleteOccurrenceMutex.Lock()
	ret, specificReturn := fake.deleteOccurrenceReturnsOnCall[len(fake.deleteOccurrenceArgsForCall)]
	fake.deleteOccurrenceArgsForCall = append(fake.deleteOccurrenceArgsForCall, struct {
		arg1 context.Context
		arg2 *grafeas_go_proto.DeleteOccurrenceRequest
		arg3 []grpc.CallOption
	}{arg1, arg2, arg3})
	stub := fake.DeleteOccurrenceStub
	fakeReturns := fake.deleteOccurrenceReturns
	fake.recordInvocation("DeleteOccurrence", []interface{}{arg1, arg2, arg3})
	fake.deleteOccurrenceMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeGrafeasV1Beta1Client) DeleteOccurrenceCallCount() int {
	fake.deleteOccurrenceMutex.RLock()
	defer fake.deleteOccurrenceMutex.RUnlock()
	return len(fake.deleteOccurrenceArgsForCall)
}

func (fake *FakeGrafeasV1Beta1Client) DeleteOccurrenceCalls(stub func(context.Context, *grafeas_go_proto.DeleteOccurrenceRequest, ...grpc.CallOption) (*emptypb.Empty, error)) {
	fake.deleteOccurrenceMutex.Lock()
	defer fake.deleteOccurrenceMutex.Unlock()
	fake.DeleteOccurrenceStub = stub
}

func (fake *FakeGrafeasV1Beta1Client) DeleteOccurrenceArgsForCall(i int) (context.Context, *grafeas_go_proto.DeleteOccurrenceRequest, []grpc.CallOption) {
	fake.deleteOccurrenceMutex.RLock()
	defer fake.deleteOccurrenceMutex.RUnlock()
	argsForCall := fake.deleteOccurrenceArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeGrafeasV1Beta1Client) DeleteOccurrenceReturns(result1 *emptypb.Empty, result2 error) {
	fake.deleteOccurrenceMutex.Lock()
	defer fake.deleteOccurrenceMutex.Unlock()
	fake.DeleteOccurrenceStub = nil
	fake.deleteOccurrenceReturns = struct {
		result1 *emptypb.Empty
		result2 error
	}{result1, result2}
}

func (fake *FakeGrafeasV1Beta1Client) DeleteOccurrenceReturnsOnCall(i int, result1 *emptypb.Empty, result2 error) {
	fake.deleteOccurrenceMutex.Lock()
	defer fake.deleteOccurrenceMutex.Unlock()
	fake.DeleteOccurrenceStub = nil
	if fake.deleteOccurrenceReturnsOnCall == nil {
		fake.deleteOccurrenceReturnsOnCall = make(map[int]struct {
			result1 *emptypb.Empty
			result2 error
		})
	}
	fake.deleteOccurrenceReturnsOnCall[i] = struct {
		result1 *emptypb.Empty
		result2 error
	}{result1, result2}
}

func (fake *FakeGrafeasV1Beta1Client) GetNote(arg1 context.Context, arg2 *grafeas_go_proto.GetNoteRequest, arg3 ...grpc.CallOption) (*grafeas_go_proto.Note, error) {
	fake.getNoteMutex.Lock()
	ret, specificReturn := fake.getNoteReturnsOnCall[len(fake.getNoteArgsForCall)]
	fake.getNoteArgsForCall = append(fake.getNoteArgsForCall, struct {
		arg1 context.Context
		arg2 *grafeas_go_proto.GetNoteRequest
		arg3 []grpc.CallOption
	}{arg1, arg2, arg3})
	stub := fake.GetNoteStub
	fakeReturns := fake.getNoteReturns
	fake.recordInvocation("GetNote", []interface{}{arg1, arg2, arg3})
	fake.getNoteMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeGrafeasV1Beta1Client) GetNoteCallCount() int {
	fake.getNoteMutex.RLock()
	defer fake.getNoteMutex.RUnlock()
	return len(fake.getNoteArgsForCall)
}

func (fake *FakeGrafeasV1Beta1Client) GetNoteCalls(stub func(context.Context, *grafeas_go_proto.GetNoteRequest, ...grpc.CallOption) (*grafeas_go_proto.Note, error)) {
	fake.getNoteMutex.Lock()
	defer fake.getNoteMutex.Unlock()
	fake.GetNoteStub = stub
}

func (fake *FakeGrafeasV1Beta1Client) GetNoteArgsForCall(i int) (context.Context, *grafeas_go_proto.GetNoteRequest, []grpc.CallOption) {
	fake.getNoteMutex.RLock()
	defer fake.getNoteMutex.RUnlock()
	argsForCall := fake.getNoteArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeGrafeasV1Beta1Client) GetNoteReturns(result1 *grafeas_go_proto.Note, result2 error) {
	fake.getNoteMutex.Lock()
	defer fake.getNoteMutex.Unlock()
	fake.GetNoteStub = nil
	fake.getNoteReturns = struct {
		result1 *grafeas_go_proto.Note
		result2 error
	}{result1, result2}
}

func (fake *FakeGrafeasV1Beta1Client) GetNoteReturnsOnCall(i int, result1 *grafeas_go_proto.Note, result2 error) {
	fake.getNoteMutex.Lock()
	defer fake.getNoteMutex.Unlock()
	fake.GetNoteStub = nil
	if fake.getNoteReturnsOnCall == nil {
		fake.getNoteReturnsOnCall = make(map[int]struct {
			result1 *grafeas_go_proto.Note
			result2 error
		})
	}
	fake.getNoteReturnsOnCall[i] = struct {
		result1 *grafeas_go_proto.Note
		result2 error
	}{result1, result2}
}

func (fake *FakeGrafeasV1Beta1Client) GetOccurrence(arg1 context.Context, arg2 *grafeas_go_proto.GetOccurrenceRequest, arg3 ...grpc.CallOption) (*grafeas_go_proto.Occurrence, error) {
	fake.getOccurrenceMutex.Lock()
	ret, specificReturn := fake.getOccurrenceReturnsOnCall[len(fake.getOccurrenceArgsForCall)]
	fake.getOccurrenceArgsForCall = append(fake.getOccurrenceArgsForCall, struct {
		arg1 context.Context
		arg2 *grafeas_go_proto.GetOccurrenceRequest
		arg3 []grpc.CallOption
	}{arg1, arg2, arg3})
	stub := fake.GetOccurrenceStub
	fakeReturns := fake.getOccurrenceReturns
	fake.recordInvocation("GetOccurrence", []interface{}{arg1, arg2, arg3})
	fake.getOccurrenceMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeGrafeasV1Beta1Client) GetOccurrenceCallCount() int {
	fake.getOccurrenceMutex.RLock()
	defer fake.getOccurrenceMutex.RUnlock()
	return len(fake.getOccurrenceArgsForCall)
}

func (fake *FakeGrafeasV1Beta1Client) GetOccurrenceCalls(stub func(context.Context, *grafeas_go_proto.GetOccurrenceRequest, ...grpc.CallOption) (*grafeas_go_proto.Occurrence, error)) {
	fake.getOccurrenceMutex.Lock()
	defer fake.getOccurrenceMutex.Unlock()
	fake.GetOccurrenceStub = stub
}

func (fake *FakeGrafeasV1Beta1Client) GetOccurrenceArgsForCall(i int) (context.Context, *grafeas_go_proto.GetOccurrenceRequest, []grpc.CallOption) {
	fake.getOccurrenceMutex.RLock()
	defer fake.getOccurrenceMutex.RUnlock()
	argsForCall := fake.getOccurrenceArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeGrafeasV1Beta1Client) GetOccurrenceReturns(result1 *grafeas_go_proto.Occurrence, result2 error) {
	fake.getOccurrenceMutex.Lock()
	defer fake.getOccurrenceMutex.Unlock()
	fake.GetOccurrenceStub = nil
	fake.getOccurrenceReturns = struct {
		result1 *grafeas_go_proto.Occurrence
		result2 error
	}{result1, result2}
}

func (fake *FakeGrafeasV1Beta1Client) GetOccurrenceReturnsOnCall(i int, result1 *grafeas_go_proto.Occurrence, result2 error) {
	fake.getOccurrenceMutex.Lock()
	defer fake.getOccurrenceMutex.Unlock()
	fake.GetOccurrenceStub = nil
	if fake.getOccurrenceReturnsOnCall == nil {
		fake.getOccurrenceReturnsOnCall = make(map[int]struct {
			result1 *grafeas_go_proto.Occurrence
			result2 error
		})
	}
	fake.getOccurrenceReturnsOnCall[i] = struct {
		result1 *grafeas_go_proto.Occurrence
		result2 error
	}{result1, result2}
}

func (fake *FakeGrafeasV1Beta1Client) GetOccurrenceNote(arg1 context.Context, arg2 *grafeas_go_proto.GetOccurrenceNoteRequest, arg3 ...grpc.CallOption) (*grafeas_go_proto.Note, error) {
	fake.getOccurrenceNoteMutex.Lock()
	ret, specificReturn := fake.getOccurrenceNoteReturnsOnCall[len(fake.getOccurrenceNoteArgsForCall)]
	fake.getOccurrenceNoteArgsForCall = append(fake.getOccurrenceNoteArgsForCall, struct {
		arg1 context.Context
		arg2 *grafeas_go_proto.GetOccurrenceNoteRequest
		arg3 []grpc.CallOption
	}{arg1, arg2, arg3})
	stub := fake.GetOccurrenceNoteStub
	fakeReturns := fake.getOccurrenceNoteReturns
	fake.recordInvocation("GetOccurrenceNote", []interface{}{arg1, arg2, arg3})
	fake.getOccurrenceNoteMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeGrafeasV1Beta1Client) GetOccurrenceNoteCallCount() int {
	fake.getOccurrenceNoteMutex.RLock()
	defer fake.getOccurrenceNoteMutex.RUnlock()
	return len(fake.getOccurrenceNoteArgsForCall)
}

func (fake *FakeGrafeasV1Beta1Client) GetOccurrenceNoteCalls(stub func(context.Context, *grafeas_go_proto.GetOccurrenceNoteRequest, ...grpc.CallOption) (*grafeas_go_proto.Note, error)) {
	fake.getOccurrenceNoteMutex.Lock()
	defer fake.getOccurrenceNoteMutex.Unlock()
	fake.GetOccurrenceNoteStub = stub
}

func (fake *FakeGrafeasV1Beta1Client) GetOccurrenceNoteArgsForCall(i int) (context.Context, *grafeas_go_proto.GetOccurrenceNoteRequest, []grpc.CallOption) {
	fake.getOccurrenceNoteMutex.RLock()
	defer fake.getOccurrenceNoteMutex.RUnlock()
	argsForCall := fake.getOccurrenceNoteArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeGrafeasV1Beta1Client) GetOccurrenceNoteReturns(result1 *grafeas_go_proto.Note, result2 error) {
	fake.getOccurrenceNoteMutex.Lock()
	defer fake.getOccurrenceNoteMutex.Unlock()
	fake.GetOccurrenceNoteStub = nil
	fake.getOccurrenceNoteReturns = struct {
		result1 *grafeas_go_proto.Note
		result2 error
	}{result1, result2}
}

func (fake *FakeGrafeasV1Beta1Client) GetOccurrenceNoteReturnsOnCall(i int, result1 *grafeas_go_proto.Note, result2 error) {
	fake.getOccurrenceNoteMutex.Lock()
	defer fake.getOccurrenceNoteMutex.Unlock()
	fake.GetOccurrenceNoteStub = nil
	if fake.getOccurrenceNoteReturnsOnCall == nil {
		fake.getOccurrenceNoteReturnsOnCall = make(map[int]struct {
			result1 *grafeas_go_proto.Note
			result2 error
		})
	}
	fake.getOccurrenceNoteReturnsOnCall[i] = struct {
		result1 *grafeas_go_proto.Note
		result2 error
	}{result1, result2}
}

func (fake *FakeGrafeasV1Beta1Client) GetVulnerabilityOccurrencesSummary(arg1 context.Context, arg2 *grafeas_go_proto.GetVulnerabilityOccurrencesSummaryRequest, arg3 ...grpc.CallOption) (*grafeas_go_proto.VulnerabilityOccurrencesSummary, error) {
	fake.getVulnerabilityOccurrencesSummaryMutex.Lock()
	ret, specificReturn := fake.getVulnerabilityOccurrencesSummaryReturnsOnCall[len(fake.getVulnerabilityOccurrencesSummaryArgsForCall)]
	fake.getVulnerabilityOccurrencesSummaryArgsForCall = append(fake.getVulnerabilityOccurrencesSummaryArgsForCall, struct {
		arg1 context.Context
		arg2 *grafeas_go_proto.GetVulnerabilityOccurrencesSummaryRequest
		arg3 []grpc.CallOption
	}{arg1, arg2, arg3})
	stub := fake.GetVulnerabilityOccurrencesSummaryStub
	fakeReturns := fake.getVulnerabilityOccurrencesSummaryReturns
	fake.recordInvocation("GetVulnerabilityOccurrencesSummary", []interface{}{arg1, arg2, arg3})
	fake.getVulnerabilityOccurrencesSummaryMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeGrafeasV1Beta1Client) GetVulnerabilityOccurrencesSummaryCallCount() int {
	fake.getVulnerabilityOccurrencesSummaryMutex.RLock()
	defer fake.getVulnerabilityOccurrencesSummaryMutex.RUnlock()
	return len(fake.getVulnerabilityOccurrencesSummaryArgsForCall)
}

func (fake *FakeGrafeasV1Beta1Client) GetVulnerabilityOccurrencesSummaryCalls(stub func(context.Context, *grafeas_go_proto.GetVulnerabilityOccurrencesSummaryRequest, ...grpc.CallOption) (*grafeas_go_proto.VulnerabilityOccurrencesSummary, error)) {
	fake.getVulnerabilityOccurrencesSummaryMutex.Lock()
	defer fake.getVulnerabilityOccurrencesSummaryMutex.Unlock()
	fake.GetVulnerabilityOccurrencesSummaryStub = stub
}

func (fake *FakeGrafeasV1Beta1Client) GetVulnerabilityOccurrencesSummaryArgsForCall(i int) (context.Context, *grafeas_go_proto.GetVulnerabilityOccurrencesSummaryRequest, []grpc.CallOption) {
	fake.getVulnerabilityOccurrencesSummaryMutex.RLock()
	defer fake.getVulnerabilityOccurrencesSummaryMutex.RUnlock()
	argsForCall := fake.getVulnerabilityOccurrencesSummaryArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeGrafeasV1Beta1Client) GetVulnerabilityOccurrencesSummaryReturns(result1 *grafeas_go_proto.VulnerabilityOccurrencesSummary, result2 error) {
	fake.getVulnerabilityOccurrencesSummaryMutex.Lock()
	defer fake.getVulnerabilityOccurrencesSummaryMutex.Unlock()
	fake.GetVulnerabilityOccurrencesSummaryStub = nil
	fake.getVulnerabilityOccurrencesSummaryReturns = struct {
		result1 *grafeas_go_proto.VulnerabilityOccurrencesSummary
		result2 error
	}{result1, result2}
}

func (fake *FakeGrafeasV1Beta1Client) GetVulnerabilityOccurrencesSummaryReturnsOnCall(i int, result1 *grafeas_go_proto.VulnerabilityOccurrencesSummary, result2 error) {
	fake.getVulnerabilityOccurrencesSummaryMutex.Lock()
	defer fake.getVulnerabilityOccurrencesSummaryMutex.Unlock()
	fake.GetVulnerabilityOccurrencesSummaryStub = nil
	if fake.getVulnerabilityOccurrencesSummaryReturnsOnCall == nil {
		fake.getVulnerabilityOccurrencesSummaryReturnsOnCall = make(map[int]struct {
			result1 *grafeas_go_proto.VulnerabilityOccurrencesSummary
			result2 error
		})
	}
	fake.getVulnerabilityOccurrencesSummaryReturnsOnCall[i] = struct {
		result1 *grafeas_go_proto.VulnerabilityOccurrencesSummary
		result2 error
	}{result1, result2}
}

func (fake *FakeGrafeasV1Beta1Client) ListNoteOccurrences(arg1 context.Context, arg2 *grafeas_go_proto.ListNoteOccurrencesRequest, arg3 ...grpc.CallOption) (*grafeas_go_proto.ListNoteOccurrencesResponse, error) {
	fake.listNoteOccurrencesMutex.Lock()
	ret, specificReturn := fake.listNoteOccurrencesReturnsOnCall[len(fake.listNoteOccurrencesArgsForCall)]
	fake.listNoteOccurrencesArgsForCall = append(fake.listNoteOccurrencesArgsForCall, struct {
		arg1 context.Context
		arg2 *grafeas_go_proto.ListNoteOccurrencesRequest
		arg3 []grpc.CallOption
	}{arg1, arg2, arg3})
	stub := fake.ListNoteOccurrencesStub
	fakeReturns := fake.listNoteOccurrencesReturns
	fake.recordInvocation("ListNoteOccurrences", []interface{}{arg1, arg2, arg3})
	fake.listNoteOccurrencesMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeGrafeasV1Beta1Client) ListNoteOccurrencesCallCount() int {
	fake.listNoteOccurrencesMutex.RLock()
	defer fake.listNoteOccurrencesMutex.RUnlock()
	return len(fake.listNoteOccurrencesArgsForCall)
}

func (fake *FakeGrafeasV1Beta1Client) ListNoteOccurrencesCalls(stub func(context.Context, *grafeas_go_proto.ListNoteOccurrencesRequest, ...grpc.CallOption) (*grafeas_go_proto.ListNoteOccurrencesResponse, error)) {
	fake.listNoteOccurrencesMutex.Lock()
	defer fake.listNoteOccurrencesMutex.Unlock()
	fake.ListNoteOccurrencesStub = stub
}

func (fake *FakeGrafeasV1Beta1Client) ListNoteOccurrencesArgsForCall(i int) (context.Context, *grafeas_go_proto.ListNoteOccurrencesRequest, []grpc.CallOption) {
	fake.listNoteOccurrencesMutex.RLock()
	defer fake.listNoteOccurrencesMutex.RUnlock()
	argsForCall := fake.listNoteOccurrencesArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeGrafeasV1Beta1Client) ListNoteOccurrencesReturns(result1 *grafeas_go_proto.ListNoteOccurrencesResponse, result2 error) {
	fake.listNoteOccurrencesMutex.Lock()
	defer fake.listNoteOccurrencesMutex.Unlock()
	fake.ListNoteOccurrencesStub = nil
	fake.listNoteOccurrencesReturns = struct {
		result1 *grafeas_go_proto.ListNoteOccurrencesResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeGrafeasV1Beta1Client) ListNoteOccurrencesReturnsOnCall(i int, result1 *grafeas_go_proto.ListNoteOccurrencesResponse, result2 error) {
	fake.listNoteOccurrencesMutex.Lock()
	defer fake.listNoteOccurrencesMutex.Unlock()
	fake.ListNoteOccurrencesStub = nil
	if fake.listNoteOccurrencesReturnsOnCall == nil {
		fake.listNoteOccurrencesReturnsOnCall = make(map[int]struct {
			result1 *grafeas_go_proto.ListNoteOccurrencesResponse
			result2 error
		})
	}
	fake.listNoteOccurrencesReturnsOnCall[i] = struct {
		result1 *grafeas_go_proto.ListNoteOccurrencesResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeGrafeasV1Beta1Client) ListNotes(arg1 context.Context, arg2 *grafeas_go_proto.ListNotesRequest, arg3 ...grpc.CallOption) (*grafeas_go_proto.ListNotesResponse, error) {
	fake.listNotesMutex.Lock()
	ret, specificReturn := fake.listNotesReturnsOnCall[len(fake.listNotesArgsForCall)]
	fake.listNotesArgsForCall = append(fake.listNotesArgsForCall, struct {
		arg1 context.Context
		arg2 *grafeas_go_proto.ListNotesRequest
		arg3 []grpc.CallOption
	}{arg1, arg2, arg3})
	stub := fake.ListNotesStub
	fakeReturns := fake.listNotesReturns
	fake.recordInvocation("ListNotes", []interface{}{arg1, arg2, arg3})
	fake.listNotesMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeGrafeasV1Beta1Client) ListNotesCallCount() int {
	fake.listNotesMutex.RLock()
	defer fake.listNotesMutex.RUnlock()
	return len(fake.listNotesArgsForCall)
}

func (fake *FakeGrafeasV1Beta1Client) ListNotesCalls(stub func(context.Context, *grafeas_go_proto.ListNotesRequest, ...grpc.CallOption) (*grafeas_go_proto.ListNotesResponse, error)) {
	fake.listNotesMutex.Lock()
	defer fake.listNotesMutex.Unlock()
	fake.ListNotesStub = stub
}

func (fake *FakeGrafeasV1Beta1Client) ListNotesArgsForCall(i int) (context.Context, *grafeas_go_proto.ListNotesRequest, []grpc.CallOption) {
	fake.listNotesMutex.RLock()
	defer fake.listNotesMutex.RUnlock()
	argsForCall := fake.listNotesArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeGrafeasV1Beta1Client) ListNotesReturns(result1 *grafeas_go_proto.ListNotesResponse, result2 error) {
	fake.listNotesMutex.Lock()
	defer fake.listNotesMutex.Unlock()
	fake.ListNotesStub = nil
	fake.listNotesReturns = struct {
		result1 *grafeas_go_proto.ListNotesResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeGrafeasV1Beta1Client) ListNotesReturnsOnCall(i int, result1 *grafeas_go_proto.ListNotesResponse, result2 error) {
	fake.listNotesMutex.Lock()
	defer fake.listNotesMutex.Unlock()
	fake.ListNotesStub = nil
	if fake.listNotesReturnsOnCall == nil {
		fake.listNotesReturnsOnCall = make(map[int]struct {
			result1 *grafeas_go_proto.ListNotesResponse
			result2 error
		})
	}
	fake.listNotesReturnsOnCall[i] = struct {
		result1 *grafeas_go_proto.ListNotesResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeGrafeasV1Beta1Client) ListOccurrences(arg1 context.Context, arg2 *grafeas_go_proto.ListOccurrencesRequest, arg3 ...grpc.CallOption) (*grafeas_go_proto.ListOccurrencesResponse, error) {
	fake.listOccurrencesMutex.Lock()
	ret, specificReturn := fake.listOccurrencesReturnsOnCall[len(fake.listOccurrencesArgsForCall)]
	fake.listOccurrencesArgsForCall = append(fake.listOccurrencesArgsForCall, struct {
		arg1 context.Context
		arg2 *grafeas_go_proto.ListOccurrencesRequest
		arg3 []grpc.CallOption
	}{arg1, arg2, arg3})
	stub := fake.ListOccurrencesStub
	fakeReturns := fake.listOccurrencesReturns
	fake.recordInvocation("ListOccurrences", []interface{}{arg1, arg2, arg3})
	fake.listOccurrencesMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeGrafeasV1Beta1Client) ListOccurrencesCallCount() int {
	fake.listOccurrencesMutex.RLock()
	defer fake.listOccurrencesMutex.RUnlock()
	return len(fake.listOccurrencesArgsForCall)
}

func (fake *FakeGrafeasV1Beta1Client) ListOccurrencesCalls(stub func(context.Context, *grafeas_go_proto.ListOccurrencesRequest, ...grpc.CallOption) (*grafeas_go_proto.ListOccurrencesResponse, error)) {
	fake.listOccurrencesMutex.Lock()
	defer fake.listOccurrencesMutex.Unlock()
	fake.ListOccurrencesStub = stub
}

func (fake *FakeGrafeasV1Beta1Client) ListOccurrencesArgsForCall(i int) (context.Context, *grafeas_go_proto.ListOccurrencesRequest, []grpc.CallOption) {
	fake.listOccurrencesMutex.RLock()
	defer fake.listOccurrencesMutex.RUnlock()
	argsForCall := fake.listOccurrencesArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeGrafeasV1Beta1Client) ListOccurrencesReturns(result1 *grafeas_go_proto.ListOccurrencesResponse, result2 error) {
	fake.listOccurrencesMutex.Lock()
	defer fake.listOccurrencesMutex.Unlock()
	fake.ListOccurrencesStub = nil
	fake.listOccurrencesReturns = struct {
		result1 *grafeas_go_proto.ListOccurrencesResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeGrafeasV1Beta1Client) ListOccurrencesReturnsOnCall(i int, result1 *grafeas_go_proto.ListOccurrencesResponse, result2 error) {
	fake.listOccurrencesMutex.Lock()
	defer fake.listOccurrencesMutex.Unlock()
	fake.ListOccurrencesStub = nil
	if fake.listOccurrencesReturnsOnCall == nil {
		fake.listOccurrencesReturnsOnCall = make(map[int]struct {
			result1 *grafeas_go_proto.ListOccurrencesResponse
			result2 error
		})
	}
	fake.listOccurrencesReturnsOnCall[i] = struct {
		result1 *grafeas_go_proto.ListOccurrencesResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeGrafeasV1Beta1Client) UpdateNote(arg1 context.Context, arg2 *grafeas_go_proto.UpdateNoteRequest, arg3 ...grpc.CallOption) (*grafeas_go_proto.Note, error) {
	fake.updateNoteMutex.Lock()
	ret, specificReturn := fake.updateNoteReturnsOnCall[len(fake.updateNoteArgsForCall)]
	fake.updateNoteArgsForCall = append(fake.updateNoteArgsForCall, struct {
		arg1 context.Context
		arg2 *grafeas_go_proto.UpdateNoteRequest
		arg3 []grpc.CallOption
	}{arg1, arg2, arg3})
	stub := fake.UpdateNoteStub
	fakeReturns := fake.updateNoteReturns
	fake.recordInvocation("UpdateNote", []interface{}{arg1, arg2, arg3})
	fake.updateNoteMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeGrafeasV1Beta1Client) UpdateNoteCallCount() int {
	fake.updateNoteMutex.RLock()
	defer fake.updateNoteMutex.RUnlock()
	return len(fake.updateNoteArgsForCall)
}

func (fake *FakeGrafeasV1Beta1Client) UpdateNoteCalls(stub func(context.Context, *grafeas_go_proto.UpdateNoteRequest, ...grpc.CallOption) (*grafeas_go_proto.Note, error)) {
	fake.updateNoteMutex.Lock()
	defer fake.updateNoteMutex.Unlock()
	fake.UpdateNoteStub = stub
}

func (fake *FakeGrafeasV1Beta1Client) UpdateNoteArgsForCall(i int) (context.Context, *grafeas_go_proto.UpdateNoteRequest, []grpc.CallOption) {
	fake.updateNoteMutex.RLock()
	defer fake.updateNoteMutex.RUnlock()
	argsForCall := fake.updateNoteArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeGrafeasV1Beta1Client) UpdateNoteReturns(result1 *grafeas_go_proto.Note, result2 error) {
	fake.updateNoteMutex.Lock()
	defer fake.updateNoteMutex.Unlock()
	fake.UpdateNoteStub = nil
	fake.updateNoteReturns = struct {
		result1 *grafeas_go_proto.Note
		result2 error
	}{result1, result2}
}

func (fake *FakeGrafeasV1Beta1Client) UpdateNoteReturnsOnCall(i int, result1 *grafeas_go_proto.Note, result2 error) {
	fake.updateNoteMutex.Lock()
	defer fake.updateNoteMutex.Unlock()
	fake.UpdateNoteStub = nil
	if fake.updateNoteReturnsOnCall == nil {
		fake.updateNoteReturnsOnCall = make(map[int]struct {
			result1 *grafeas_go_proto.Note
			result2 error
		})
	}
	fake.updateNoteReturnsOnCall[i] = struct {
		result1 *grafeas_go_proto.Note
		result2 error
	}{result1, result2}
}

func (fake *FakeGrafeasV1Beta1Client) UpdateOccurrence(arg1 context.Context, arg2 *grafeas_go_proto.UpdateOccurrenceRequest, arg3 ...grpc.CallOption) (*grafeas_go_proto.Occurrence, error) {
	fake.updateOccurrenceMutex.Lock()
	ret, specificReturn := fake.updateOccurrenceReturnsOnCall[len(fake.updateOccurrenceArgsForCall)]
	fake.updateOccurrenceArgsForCall = append(fake.updateOccurrenceArgsForCall, struct {
		arg1 context.Context
		arg2 *grafeas_go_proto.UpdateOccurrenceRequest
		arg3 []grpc.CallOption
	}{arg1, arg2, arg3})
	stub := fake.UpdateOccurrenceStub
	fakeReturns := fake.updateOccurrenceReturns
	fake.recordInvocation("UpdateOccurrence", []interface{}{arg1, arg2, arg3})
	fake.updateOccurrenceMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeGrafeasV1Beta1Client) UpdateOccurrenceCallCount() int {
	fake.updateOccurrenceMutex.RLock()
	defer fake.updateOccurrenceMutex.RUnlock()
	return len(fake.updateOccurrenceArgsForCall)
}

func (fake *FakeGrafeasV1Beta1Client) UpdateOccurrenceCalls(stub func(context.Context, *grafeas_go_proto.UpdateOccurrenceRequest, ...grpc.CallOption) (*grafeas_go_proto.Occurrence, error)) {
	fake.updateOccurrenceMutex.Lock()
	defer fake.updateOccurrenceMutex.Unlock()
	fake.UpdateOccurrenceStub = stub
}

func (fake *FakeGrafeasV1Beta1Client) UpdateOccurrenceArgsForCall(i int) (context.Context, *grafeas_go_proto.UpdateOccurrenceRequest, []grpc.CallOption) {
	fake.updateOccurrenceMutex.RLock()
	defer fake.updateOccurrenceMutex.RUnlock()
	argsForCall := fake.updateOccurrenceArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeGrafeasV1Beta1Client) UpdateOccurrenceReturns(result1 *grafeas_go_proto.Occurrence, result2 error) {
	fake.updateOccurrenceMutex.Lock()
	defer fake.updateOccurrenceMutex.Unlock()
	fake.UpdateOccurrenceStub = nil
	fake.updateOccurrenceReturns = struct {
		result1 *grafeas_go_proto.Occurrence
		result2 error
	}{result1, result2}
}

func (fake *FakeGrafeasV1Beta1Client) UpdateOccurrenceReturnsOnCall(i int, result1 *grafeas_go_proto.Occurrence, result2 error) {
	fake.updateOccurrenceMutex.Lock()
	defer fake.updateOccurrenceMutex.Unlock()
	fake.UpdateOccurrenceStub = nil
	if fake.updateOccurrenceReturnsOnCall == nil {
		fake.updateOccurrenceReturnsOnCall = make(map[int]struct {
			result1 *grafeas_go_proto.Occurrence
			result2 error
		})
	}
	fake.updateOccurrenceReturnsOnCall[i] = struct {
		result1 *grafeas_go_proto.Occurrence
		result2 error
	}{result1, result2}
}

func (fake *FakeGrafeasV1Beta1Client) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.batchCreateNotesMutex.RLock()
	defer fake.batchCreateNotesMutex.RUnlock()
	fake.batchCreateOccurrencesMutex.RLock()
	defer fake.batchCreateOccurrencesMutex.RUnlock()
	fake.createNoteMutex.RLock()
	defer fake.createNoteMutex.RUnlock()
	fake.createOccurrenceMutex.RLock()
	defer fake.createOccurrenceMutex.RUnlock()
	fake.deleteNoteMutex.RLock()
	defer fake.deleteNoteMutex.RUnlock()
	fake.deleteOccurrenceMutex.RLock()
	defer fake.deleteOccurrenceMutex.RUnlock()
	fake.getNoteMutex.RLock()
	defer fake.getNoteMutex.RUnlock()
	fake.getOccurrenceMutex.RLock()
	defer fake.getOccurrenceMutex.RUnlock()
	fake.getOccurrenceNoteMutex.RLock()
	defer fake.getOccurrenceNoteMutex.RUnlock()
	fake.getVulnerabilityOccurrencesSummaryMutex.RLock()
	defer fake.getVulnerabilityOccurrencesSummaryMutex.RUnlock()
	fake.listNoteOccurrencesMutex.RLock()
	defer fake.listNoteOccurrencesMutex.RUnlock()
	fake.listNotesMutex.RLock()
	defer fake.listNotesMutex.RUnlock()
	fake.listOccurrencesMutex.RLock()
	defer fake.listOccurrencesMutex.RUnlock()
	fake.updateNoteMutex.RLock()
	defer fake.updateNoteMutex.RUnlock()
	fake.updateOccurrenceMutex.RLock()
	defer fake.updateOccurrenceMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeGrafeasV1Beta1Client) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ grafeas_go_proto.GrafeasV1Beta1Client = new(FakeGrafeasV1Beta1Client)
