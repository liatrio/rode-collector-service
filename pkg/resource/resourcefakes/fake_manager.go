// Code generated by counterfeiter. DO NOT EDIT.
package resourcefakes

import (
	"context"
	"sync"

	"github.com/rode/rode/pkg/resource"
	"github.com/rode/rode/proto/v1alpha1"
	"github.com/rode/rode/protodeps/grafeas/proto/v1beta1/grafeas_go_proto"
)

type FakeManager struct {
	BatchCreateResourceVersionsStub        func(context.Context, []*grafeas_go_proto.Occurrence) error
	batchCreateResourceVersionsMutex       sync.RWMutex
	batchCreateResourceVersionsArgsForCall []struct {
		arg1 context.Context
		arg2 []*grafeas_go_proto.Occurrence
	}
	batchCreateResourceVersionsReturns struct {
		result1 error
	}
	batchCreateResourceVersionsReturnsOnCall map[int]struct {
		result1 error
	}
	BatchCreateResourcesStub        func(context.Context, []*grafeas_go_proto.Occurrence) error
	batchCreateResourcesMutex       sync.RWMutex
	batchCreateResourcesArgsForCall []struct {
		arg1 context.Context
		arg2 []*grafeas_go_proto.Occurrence
	}
	batchCreateResourcesReturns struct {
		result1 error
	}
	batchCreateResourcesReturnsOnCall map[int]struct {
		result1 error
	}
	GetResourceStub        func(context.Context, string) (*v1alpha1.Resource, error)
	getResourceMutex       sync.RWMutex
	getResourceArgsForCall []struct {
		arg1 context.Context
		arg2 string
	}
	getResourceReturns struct {
		result1 *v1alpha1.Resource
		result2 error
	}
	getResourceReturnsOnCall map[int]struct {
		result1 *v1alpha1.Resource
		result2 error
	}
	GetResourceVersionStub        func(context.Context, string) (*v1alpha1.ResourceVersion, error)
	getResourceVersionMutex       sync.RWMutex
	getResourceVersionArgsForCall []struct {
		arg1 context.Context
		arg2 string
	}
	getResourceVersionReturns struct {
		result1 *v1alpha1.ResourceVersion
		result2 error
	}
	getResourceVersionReturnsOnCall map[int]struct {
		result1 *v1alpha1.ResourceVersion
		result2 error
	}
	ListResourceVersionsStub        func(context.Context, *v1alpha1.ListResourceVersionsRequest) (*v1alpha1.ListResourceVersionsResponse, error)
	listResourceVersionsMutex       sync.RWMutex
	listResourceVersionsArgsForCall []struct {
		arg1 context.Context
		arg2 *v1alpha1.ListResourceVersionsRequest
	}
	listResourceVersionsReturns struct {
		result1 *v1alpha1.ListResourceVersionsResponse
		result2 error
	}
	listResourceVersionsReturnsOnCall map[int]struct {
		result1 *v1alpha1.ListResourceVersionsResponse
		result2 error
	}
	ListResourcesStub        func(context.Context, *v1alpha1.ListResourcesRequest) (*v1alpha1.ListResourcesResponse, error)
	listResourcesMutex       sync.RWMutex
	listResourcesArgsForCall []struct {
		arg1 context.Context
		arg2 *v1alpha1.ListResourcesRequest
	}
	listResourcesReturns struct {
		result1 *v1alpha1.ListResourcesResponse
		result2 error
	}
	listResourcesReturnsOnCall map[int]struct {
		result1 *v1alpha1.ListResourcesResponse
		result2 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeManager) BatchCreateResourceVersions(arg1 context.Context, arg2 []*grafeas_go_proto.Occurrence) error {
	var arg2Copy []*grafeas_go_proto.Occurrence
	if arg2 != nil {
		arg2Copy = make([]*grafeas_go_proto.Occurrence, len(arg2))
		copy(arg2Copy, arg2)
	}
	fake.batchCreateResourceVersionsMutex.Lock()
	ret, specificReturn := fake.batchCreateResourceVersionsReturnsOnCall[len(fake.batchCreateResourceVersionsArgsForCall)]
	fake.batchCreateResourceVersionsArgsForCall = append(fake.batchCreateResourceVersionsArgsForCall, struct {
		arg1 context.Context
		arg2 []*grafeas_go_proto.Occurrence
	}{arg1, arg2Copy})
	stub := fake.BatchCreateResourceVersionsStub
	fakeReturns := fake.batchCreateResourceVersionsReturns
	fake.recordInvocation("BatchCreateResourceVersions", []interface{}{arg1, arg2Copy})
	fake.batchCreateResourceVersionsMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeManager) BatchCreateResourceVersionsCallCount() int {
	fake.batchCreateResourceVersionsMutex.RLock()
	defer fake.batchCreateResourceVersionsMutex.RUnlock()
	return len(fake.batchCreateResourceVersionsArgsForCall)
}

func (fake *FakeManager) BatchCreateResourceVersionsCalls(stub func(context.Context, []*grafeas_go_proto.Occurrence) error) {
	fake.batchCreateResourceVersionsMutex.Lock()
	defer fake.batchCreateResourceVersionsMutex.Unlock()
	fake.BatchCreateResourceVersionsStub = stub
}

func (fake *FakeManager) BatchCreateResourceVersionsArgsForCall(i int) (context.Context, []*grafeas_go_proto.Occurrence) {
	fake.batchCreateResourceVersionsMutex.RLock()
	defer fake.batchCreateResourceVersionsMutex.RUnlock()
	argsForCall := fake.batchCreateResourceVersionsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeManager) BatchCreateResourceVersionsReturns(result1 error) {
	fake.batchCreateResourceVersionsMutex.Lock()
	defer fake.batchCreateResourceVersionsMutex.Unlock()
	fake.BatchCreateResourceVersionsStub = nil
	fake.batchCreateResourceVersionsReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeManager) BatchCreateResourceVersionsReturnsOnCall(i int, result1 error) {
	fake.batchCreateResourceVersionsMutex.Lock()
	defer fake.batchCreateResourceVersionsMutex.Unlock()
	fake.BatchCreateResourceVersionsStub = nil
	if fake.batchCreateResourceVersionsReturnsOnCall == nil {
		fake.batchCreateResourceVersionsReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.batchCreateResourceVersionsReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeManager) BatchCreateResources(arg1 context.Context, arg2 []*grafeas_go_proto.Occurrence) error {
	var arg2Copy []*grafeas_go_proto.Occurrence
	if arg2 != nil {
		arg2Copy = make([]*grafeas_go_proto.Occurrence, len(arg2))
		copy(arg2Copy, arg2)
	}
	fake.batchCreateResourcesMutex.Lock()
	ret, specificReturn := fake.batchCreateResourcesReturnsOnCall[len(fake.batchCreateResourcesArgsForCall)]
	fake.batchCreateResourcesArgsForCall = append(fake.batchCreateResourcesArgsForCall, struct {
		arg1 context.Context
		arg2 []*grafeas_go_proto.Occurrence
	}{arg1, arg2Copy})
	stub := fake.BatchCreateResourcesStub
	fakeReturns := fake.batchCreateResourcesReturns
	fake.recordInvocation("BatchCreateResources", []interface{}{arg1, arg2Copy})
	fake.batchCreateResourcesMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeManager) BatchCreateResourcesCallCount() int {
	fake.batchCreateResourcesMutex.RLock()
	defer fake.batchCreateResourcesMutex.RUnlock()
	return len(fake.batchCreateResourcesArgsForCall)
}

func (fake *FakeManager) BatchCreateResourcesCalls(stub func(context.Context, []*grafeas_go_proto.Occurrence) error) {
	fake.batchCreateResourcesMutex.Lock()
	defer fake.batchCreateResourcesMutex.Unlock()
	fake.BatchCreateResourcesStub = stub
}

func (fake *FakeManager) BatchCreateResourcesArgsForCall(i int) (context.Context, []*grafeas_go_proto.Occurrence) {
	fake.batchCreateResourcesMutex.RLock()
	defer fake.batchCreateResourcesMutex.RUnlock()
	argsForCall := fake.batchCreateResourcesArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeManager) BatchCreateResourcesReturns(result1 error) {
	fake.batchCreateResourcesMutex.Lock()
	defer fake.batchCreateResourcesMutex.Unlock()
	fake.BatchCreateResourcesStub = nil
	fake.batchCreateResourcesReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeManager) BatchCreateResourcesReturnsOnCall(i int, result1 error) {
	fake.batchCreateResourcesMutex.Lock()
	defer fake.batchCreateResourcesMutex.Unlock()
	fake.BatchCreateResourcesStub = nil
	if fake.batchCreateResourcesReturnsOnCall == nil {
		fake.batchCreateResourcesReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.batchCreateResourcesReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeManager) GetResource(arg1 context.Context, arg2 string) (*v1alpha1.Resource, error) {
	fake.getResourceMutex.Lock()
	ret, specificReturn := fake.getResourceReturnsOnCall[len(fake.getResourceArgsForCall)]
	fake.getResourceArgsForCall = append(fake.getResourceArgsForCall, struct {
		arg1 context.Context
		arg2 string
	}{arg1, arg2})
	stub := fake.GetResourceStub
	fakeReturns := fake.getResourceReturns
	fake.recordInvocation("GetResource", []interface{}{arg1, arg2})
	fake.getResourceMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeManager) GetResourceCallCount() int {
	fake.getResourceMutex.RLock()
	defer fake.getResourceMutex.RUnlock()
	return len(fake.getResourceArgsForCall)
}

func (fake *FakeManager) GetResourceCalls(stub func(context.Context, string) (*v1alpha1.Resource, error)) {
	fake.getResourceMutex.Lock()
	defer fake.getResourceMutex.Unlock()
	fake.GetResourceStub = stub
}

func (fake *FakeManager) GetResourceArgsForCall(i int) (context.Context, string) {
	fake.getResourceMutex.RLock()
	defer fake.getResourceMutex.RUnlock()
	argsForCall := fake.getResourceArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeManager) GetResourceReturns(result1 *v1alpha1.Resource, result2 error) {
	fake.getResourceMutex.Lock()
	defer fake.getResourceMutex.Unlock()
	fake.GetResourceStub = nil
	fake.getResourceReturns = struct {
		result1 *v1alpha1.Resource
		result2 error
	}{result1, result2}
}

func (fake *FakeManager) GetResourceReturnsOnCall(i int, result1 *v1alpha1.Resource, result2 error) {
	fake.getResourceMutex.Lock()
	defer fake.getResourceMutex.Unlock()
	fake.GetResourceStub = nil
	if fake.getResourceReturnsOnCall == nil {
		fake.getResourceReturnsOnCall = make(map[int]struct {
			result1 *v1alpha1.Resource
			result2 error
		})
	}
	fake.getResourceReturnsOnCall[i] = struct {
		result1 *v1alpha1.Resource
		result2 error
	}{result1, result2}
}

func (fake *FakeManager) GetResourceVersion(arg1 context.Context, arg2 string) (*v1alpha1.ResourceVersion, error) {
	fake.getResourceVersionMutex.Lock()
	ret, specificReturn := fake.getResourceVersionReturnsOnCall[len(fake.getResourceVersionArgsForCall)]
	fake.getResourceVersionArgsForCall = append(fake.getResourceVersionArgsForCall, struct {
		arg1 context.Context
		arg2 string
	}{arg1, arg2})
	stub := fake.GetResourceVersionStub
	fakeReturns := fake.getResourceVersionReturns
	fake.recordInvocation("GetResourceVersion", []interface{}{arg1, arg2})
	fake.getResourceVersionMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeManager) GetResourceVersionCallCount() int {
	fake.getResourceVersionMutex.RLock()
	defer fake.getResourceVersionMutex.RUnlock()
	return len(fake.getResourceVersionArgsForCall)
}

func (fake *FakeManager) GetResourceVersionCalls(stub func(context.Context, string) (*v1alpha1.ResourceVersion, error)) {
	fake.getResourceVersionMutex.Lock()
	defer fake.getResourceVersionMutex.Unlock()
	fake.GetResourceVersionStub = stub
}

func (fake *FakeManager) GetResourceVersionArgsForCall(i int) (context.Context, string) {
	fake.getResourceVersionMutex.RLock()
	defer fake.getResourceVersionMutex.RUnlock()
	argsForCall := fake.getResourceVersionArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeManager) GetResourceVersionReturns(result1 *v1alpha1.ResourceVersion, result2 error) {
	fake.getResourceVersionMutex.Lock()
	defer fake.getResourceVersionMutex.Unlock()
	fake.GetResourceVersionStub = nil
	fake.getResourceVersionReturns = struct {
		result1 *v1alpha1.ResourceVersion
		result2 error
	}{result1, result2}
}

func (fake *FakeManager) GetResourceVersionReturnsOnCall(i int, result1 *v1alpha1.ResourceVersion, result2 error) {
	fake.getResourceVersionMutex.Lock()
	defer fake.getResourceVersionMutex.Unlock()
	fake.GetResourceVersionStub = nil
	if fake.getResourceVersionReturnsOnCall == nil {
		fake.getResourceVersionReturnsOnCall = make(map[int]struct {
			result1 *v1alpha1.ResourceVersion
			result2 error
		})
	}
	fake.getResourceVersionReturnsOnCall[i] = struct {
		result1 *v1alpha1.ResourceVersion
		result2 error
	}{result1, result2}
}

func (fake *FakeManager) ListResourceVersions(arg1 context.Context, arg2 *v1alpha1.ListResourceVersionsRequest) (*v1alpha1.ListResourceVersionsResponse, error) {
	fake.listResourceVersionsMutex.Lock()
	ret, specificReturn := fake.listResourceVersionsReturnsOnCall[len(fake.listResourceVersionsArgsForCall)]
	fake.listResourceVersionsArgsForCall = append(fake.listResourceVersionsArgsForCall, struct {
		arg1 context.Context
		arg2 *v1alpha1.ListResourceVersionsRequest
	}{arg1, arg2})
	stub := fake.ListResourceVersionsStub
	fakeReturns := fake.listResourceVersionsReturns
	fake.recordInvocation("ListResourceVersions", []interface{}{arg1, arg2})
	fake.listResourceVersionsMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeManager) ListResourceVersionsCallCount() int {
	fake.listResourceVersionsMutex.RLock()
	defer fake.listResourceVersionsMutex.RUnlock()
	return len(fake.listResourceVersionsArgsForCall)
}

func (fake *FakeManager) ListResourceVersionsCalls(stub func(context.Context, *v1alpha1.ListResourceVersionsRequest) (*v1alpha1.ListResourceVersionsResponse, error)) {
	fake.listResourceVersionsMutex.Lock()
	defer fake.listResourceVersionsMutex.Unlock()
	fake.ListResourceVersionsStub = stub
}

func (fake *FakeManager) ListResourceVersionsArgsForCall(i int) (context.Context, *v1alpha1.ListResourceVersionsRequest) {
	fake.listResourceVersionsMutex.RLock()
	defer fake.listResourceVersionsMutex.RUnlock()
	argsForCall := fake.listResourceVersionsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeManager) ListResourceVersionsReturns(result1 *v1alpha1.ListResourceVersionsResponse, result2 error) {
	fake.listResourceVersionsMutex.Lock()
	defer fake.listResourceVersionsMutex.Unlock()
	fake.ListResourceVersionsStub = nil
	fake.listResourceVersionsReturns = struct {
		result1 *v1alpha1.ListResourceVersionsResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeManager) ListResourceVersionsReturnsOnCall(i int, result1 *v1alpha1.ListResourceVersionsResponse, result2 error) {
	fake.listResourceVersionsMutex.Lock()
	defer fake.listResourceVersionsMutex.Unlock()
	fake.ListResourceVersionsStub = nil
	if fake.listResourceVersionsReturnsOnCall == nil {
		fake.listResourceVersionsReturnsOnCall = make(map[int]struct {
			result1 *v1alpha1.ListResourceVersionsResponse
			result2 error
		})
	}
	fake.listResourceVersionsReturnsOnCall[i] = struct {
		result1 *v1alpha1.ListResourceVersionsResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeManager) ListResources(arg1 context.Context, arg2 *v1alpha1.ListResourcesRequest) (*v1alpha1.ListResourcesResponse, error) {
	fake.listResourcesMutex.Lock()
	ret, specificReturn := fake.listResourcesReturnsOnCall[len(fake.listResourcesArgsForCall)]
	fake.listResourcesArgsForCall = append(fake.listResourcesArgsForCall, struct {
		arg1 context.Context
		arg2 *v1alpha1.ListResourcesRequest
	}{arg1, arg2})
	stub := fake.ListResourcesStub
	fakeReturns := fake.listResourcesReturns
	fake.recordInvocation("ListResources", []interface{}{arg1, arg2})
	fake.listResourcesMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeManager) ListResourcesCallCount() int {
	fake.listResourcesMutex.RLock()
	defer fake.listResourcesMutex.RUnlock()
	return len(fake.listResourcesArgsForCall)
}

func (fake *FakeManager) ListResourcesCalls(stub func(context.Context, *v1alpha1.ListResourcesRequest) (*v1alpha1.ListResourcesResponse, error)) {
	fake.listResourcesMutex.Lock()
	defer fake.listResourcesMutex.Unlock()
	fake.ListResourcesStub = stub
}

func (fake *FakeManager) ListResourcesArgsForCall(i int) (context.Context, *v1alpha1.ListResourcesRequest) {
	fake.listResourcesMutex.RLock()
	defer fake.listResourcesMutex.RUnlock()
	argsForCall := fake.listResourcesArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeManager) ListResourcesReturns(result1 *v1alpha1.ListResourcesResponse, result2 error) {
	fake.listResourcesMutex.Lock()
	defer fake.listResourcesMutex.Unlock()
	fake.ListResourcesStub = nil
	fake.listResourcesReturns = struct {
		result1 *v1alpha1.ListResourcesResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeManager) ListResourcesReturnsOnCall(i int, result1 *v1alpha1.ListResourcesResponse, result2 error) {
	fake.listResourcesMutex.Lock()
	defer fake.listResourcesMutex.Unlock()
	fake.ListResourcesStub = nil
	if fake.listResourcesReturnsOnCall == nil {
		fake.listResourcesReturnsOnCall = make(map[int]struct {
			result1 *v1alpha1.ListResourcesResponse
			result2 error
		})
	}
	fake.listResourcesReturnsOnCall[i] = struct {
		result1 *v1alpha1.ListResourcesResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeManager) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.batchCreateResourceVersionsMutex.RLock()
	defer fake.batchCreateResourceVersionsMutex.RUnlock()
	fake.batchCreateResourcesMutex.RLock()
	defer fake.batchCreateResourcesMutex.RUnlock()
	fake.getResourceMutex.RLock()
	defer fake.getResourceMutex.RUnlock()
	fake.getResourceVersionMutex.RLock()
	defer fake.getResourceVersionMutex.RUnlock()
	fake.listResourceVersionsMutex.RLock()
	defer fake.listResourceVersionsMutex.RUnlock()
	fake.listResourcesMutex.RLock()
	defer fake.listResourcesMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeManager) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ resource.Manager = new(FakeManager)
