// Code generated by counterfeiter. DO NOT EDIT.
package policyfakes

import (
	"context"
	"sync"

	"github.com/rode/rode/pkg/policy"
	"github.com/rode/rode/proto/v1alpha1"
	"google.golang.org/protobuf/types/known/emptypb"
)

type FakeManager struct {
	CreatePolicyStub        func(context.Context, *v1alpha1.Policy) (*v1alpha1.Policy, error)
	createPolicyMutex       sync.RWMutex
	createPolicyArgsForCall []struct {
		arg1 context.Context
		arg2 *v1alpha1.Policy
	}
	createPolicyReturns struct {
		result1 *v1alpha1.Policy
		result2 error
	}
	createPolicyReturnsOnCall map[int]struct {
		result1 *v1alpha1.Policy
		result2 error
	}
	DeletePolicyStub        func(context.Context, *v1alpha1.DeletePolicyRequest) (*emptypb.Empty, error)
	deletePolicyMutex       sync.RWMutex
	deletePolicyArgsForCall []struct {
		arg1 context.Context
		arg2 *v1alpha1.DeletePolicyRequest
	}
	deletePolicyReturns struct {
		result1 *emptypb.Empty
		result2 error
	}
	deletePolicyReturnsOnCall map[int]struct {
		result1 *emptypb.Empty
		result2 error
	}
	EvaluatePolicyStub        func(context.Context, *v1alpha1.EvaluatePolicyRequest) (*v1alpha1.EvaluatePolicyResponse, error)
	evaluatePolicyMutex       sync.RWMutex
	evaluatePolicyArgsForCall []struct {
		arg1 context.Context
		arg2 *v1alpha1.EvaluatePolicyRequest
	}
	evaluatePolicyReturns struct {
		result1 *v1alpha1.EvaluatePolicyResponse
		result2 error
	}
	evaluatePolicyReturnsOnCall map[int]struct {
		result1 *v1alpha1.EvaluatePolicyResponse
		result2 error
	}
	GetPolicyStub        func(context.Context, *v1alpha1.GetPolicyRequest) (*v1alpha1.Policy, error)
	getPolicyMutex       sync.RWMutex
	getPolicyArgsForCall []struct {
		arg1 context.Context
		arg2 *v1alpha1.GetPolicyRequest
	}
	getPolicyReturns struct {
		result1 *v1alpha1.Policy
		result2 error
	}
	getPolicyReturnsOnCall map[int]struct {
		result1 *v1alpha1.Policy
		result2 error
	}
	ListPoliciesStub        func(context.Context, *v1alpha1.ListPoliciesRequest) (*v1alpha1.ListPoliciesResponse, error)
	listPoliciesMutex       sync.RWMutex
	listPoliciesArgsForCall []struct {
		arg1 context.Context
		arg2 *v1alpha1.ListPoliciesRequest
	}
	listPoliciesReturns struct {
		result1 *v1alpha1.ListPoliciesResponse
		result2 error
	}
	listPoliciesReturnsOnCall map[int]struct {
		result1 *v1alpha1.ListPoliciesResponse
		result2 error
	}
	ListPolicyVersionsStub        func(context.Context, *v1alpha1.ListPolicyVersionsRequest) (*v1alpha1.ListPolicyVersionsResponse, error)
	listPolicyVersionsMutex       sync.RWMutex
	listPolicyVersionsArgsForCall []struct {
		arg1 context.Context
		arg2 *v1alpha1.ListPolicyVersionsRequest
	}
	listPolicyVersionsReturns struct {
		result1 *v1alpha1.ListPolicyVersionsResponse
		result2 error
	}
	listPolicyVersionsReturnsOnCall map[int]struct {
		result1 *v1alpha1.ListPolicyVersionsResponse
		result2 error
	}
	UpdatePolicyStub        func(context.Context, *v1alpha1.UpdatePolicyRequest) (*v1alpha1.Policy, error)
	updatePolicyMutex       sync.RWMutex
	updatePolicyArgsForCall []struct {
		arg1 context.Context
		arg2 *v1alpha1.UpdatePolicyRequest
	}
	updatePolicyReturns struct {
		result1 *v1alpha1.Policy
		result2 error
	}
	updatePolicyReturnsOnCall map[int]struct {
		result1 *v1alpha1.Policy
		result2 error
	}
	ValidatePolicyStub        func(context.Context, *v1alpha1.ValidatePolicyRequest) (*v1alpha1.ValidatePolicyResponse, error)
	validatePolicyMutex       sync.RWMutex
	validatePolicyArgsForCall []struct {
		arg1 context.Context
		arg2 *v1alpha1.ValidatePolicyRequest
	}
	validatePolicyReturns struct {
		result1 *v1alpha1.ValidatePolicyResponse
		result2 error
	}
	validatePolicyReturnsOnCall map[int]struct {
		result1 *v1alpha1.ValidatePolicyResponse
		result2 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeManager) CreatePolicy(arg1 context.Context, arg2 *v1alpha1.Policy) (*v1alpha1.Policy, error) {
	fake.createPolicyMutex.Lock()
	ret, specificReturn := fake.createPolicyReturnsOnCall[len(fake.createPolicyArgsForCall)]
	fake.createPolicyArgsForCall = append(fake.createPolicyArgsForCall, struct {
		arg1 context.Context
		arg2 *v1alpha1.Policy
	}{arg1, arg2})
	stub := fake.CreatePolicyStub
	fakeReturns := fake.createPolicyReturns
	fake.recordInvocation("CreatePolicy", []interface{}{arg1, arg2})
	fake.createPolicyMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeManager) CreatePolicyCallCount() int {
	fake.createPolicyMutex.RLock()
	defer fake.createPolicyMutex.RUnlock()
	return len(fake.createPolicyArgsForCall)
}

func (fake *FakeManager) CreatePolicyCalls(stub func(context.Context, *v1alpha1.Policy) (*v1alpha1.Policy, error)) {
	fake.createPolicyMutex.Lock()
	defer fake.createPolicyMutex.Unlock()
	fake.CreatePolicyStub = stub
}

func (fake *FakeManager) CreatePolicyArgsForCall(i int) (context.Context, *v1alpha1.Policy) {
	fake.createPolicyMutex.RLock()
	defer fake.createPolicyMutex.RUnlock()
	argsForCall := fake.createPolicyArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeManager) CreatePolicyReturns(result1 *v1alpha1.Policy, result2 error) {
	fake.createPolicyMutex.Lock()
	defer fake.createPolicyMutex.Unlock()
	fake.CreatePolicyStub = nil
	fake.createPolicyReturns = struct {
		result1 *v1alpha1.Policy
		result2 error
	}{result1, result2}
}

func (fake *FakeManager) CreatePolicyReturnsOnCall(i int, result1 *v1alpha1.Policy, result2 error) {
	fake.createPolicyMutex.Lock()
	defer fake.createPolicyMutex.Unlock()
	fake.CreatePolicyStub = nil
	if fake.createPolicyReturnsOnCall == nil {
		fake.createPolicyReturnsOnCall = make(map[int]struct {
			result1 *v1alpha1.Policy
			result2 error
		})
	}
	fake.createPolicyReturnsOnCall[i] = struct {
		result1 *v1alpha1.Policy
		result2 error
	}{result1, result2}
}

func (fake *FakeManager) DeletePolicy(arg1 context.Context, arg2 *v1alpha1.DeletePolicyRequest) (*emptypb.Empty, error) {
	fake.deletePolicyMutex.Lock()
	ret, specificReturn := fake.deletePolicyReturnsOnCall[len(fake.deletePolicyArgsForCall)]
	fake.deletePolicyArgsForCall = append(fake.deletePolicyArgsForCall, struct {
		arg1 context.Context
		arg2 *v1alpha1.DeletePolicyRequest
	}{arg1, arg2})
	stub := fake.DeletePolicyStub
	fakeReturns := fake.deletePolicyReturns
	fake.recordInvocation("DeletePolicy", []interface{}{arg1, arg2})
	fake.deletePolicyMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeManager) DeletePolicyCallCount() int {
	fake.deletePolicyMutex.RLock()
	defer fake.deletePolicyMutex.RUnlock()
	return len(fake.deletePolicyArgsForCall)
}

func (fake *FakeManager) DeletePolicyCalls(stub func(context.Context, *v1alpha1.DeletePolicyRequest) (*emptypb.Empty, error)) {
	fake.deletePolicyMutex.Lock()
	defer fake.deletePolicyMutex.Unlock()
	fake.DeletePolicyStub = stub
}

func (fake *FakeManager) DeletePolicyArgsForCall(i int) (context.Context, *v1alpha1.DeletePolicyRequest) {
	fake.deletePolicyMutex.RLock()
	defer fake.deletePolicyMutex.RUnlock()
	argsForCall := fake.deletePolicyArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeManager) DeletePolicyReturns(result1 *emptypb.Empty, result2 error) {
	fake.deletePolicyMutex.Lock()
	defer fake.deletePolicyMutex.Unlock()
	fake.DeletePolicyStub = nil
	fake.deletePolicyReturns = struct {
		result1 *emptypb.Empty
		result2 error
	}{result1, result2}
}

func (fake *FakeManager) DeletePolicyReturnsOnCall(i int, result1 *emptypb.Empty, result2 error) {
	fake.deletePolicyMutex.Lock()
	defer fake.deletePolicyMutex.Unlock()
	fake.DeletePolicyStub = nil
	if fake.deletePolicyReturnsOnCall == nil {
		fake.deletePolicyReturnsOnCall = make(map[int]struct {
			result1 *emptypb.Empty
			result2 error
		})
	}
	fake.deletePolicyReturnsOnCall[i] = struct {
		result1 *emptypb.Empty
		result2 error
	}{result1, result2}
}

func (fake *FakeManager) EvaluatePolicy(arg1 context.Context, arg2 *v1alpha1.EvaluatePolicyRequest) (*v1alpha1.EvaluatePolicyResponse, error) {
	fake.evaluatePolicyMutex.Lock()
	ret, specificReturn := fake.evaluatePolicyReturnsOnCall[len(fake.evaluatePolicyArgsForCall)]
	fake.evaluatePolicyArgsForCall = append(fake.evaluatePolicyArgsForCall, struct {
		arg1 context.Context
		arg2 *v1alpha1.EvaluatePolicyRequest
	}{arg1, arg2})
	stub := fake.EvaluatePolicyStub
	fakeReturns := fake.evaluatePolicyReturns
	fake.recordInvocation("EvaluatePolicy", []interface{}{arg1, arg2})
	fake.evaluatePolicyMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeManager) EvaluatePolicyCallCount() int {
	fake.evaluatePolicyMutex.RLock()
	defer fake.evaluatePolicyMutex.RUnlock()
	return len(fake.evaluatePolicyArgsForCall)
}

func (fake *FakeManager) EvaluatePolicyCalls(stub func(context.Context, *v1alpha1.EvaluatePolicyRequest) (*v1alpha1.EvaluatePolicyResponse, error)) {
	fake.evaluatePolicyMutex.Lock()
	defer fake.evaluatePolicyMutex.Unlock()
	fake.EvaluatePolicyStub = stub
}

func (fake *FakeManager) EvaluatePolicyArgsForCall(i int) (context.Context, *v1alpha1.EvaluatePolicyRequest) {
	fake.evaluatePolicyMutex.RLock()
	defer fake.evaluatePolicyMutex.RUnlock()
	argsForCall := fake.evaluatePolicyArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeManager) EvaluatePolicyReturns(result1 *v1alpha1.EvaluatePolicyResponse, result2 error) {
	fake.evaluatePolicyMutex.Lock()
	defer fake.evaluatePolicyMutex.Unlock()
	fake.EvaluatePolicyStub = nil
	fake.evaluatePolicyReturns = struct {
		result1 *v1alpha1.EvaluatePolicyResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeManager) EvaluatePolicyReturnsOnCall(i int, result1 *v1alpha1.EvaluatePolicyResponse, result2 error) {
	fake.evaluatePolicyMutex.Lock()
	defer fake.evaluatePolicyMutex.Unlock()
	fake.EvaluatePolicyStub = nil
	if fake.evaluatePolicyReturnsOnCall == nil {
		fake.evaluatePolicyReturnsOnCall = make(map[int]struct {
			result1 *v1alpha1.EvaluatePolicyResponse
			result2 error
		})
	}
	fake.evaluatePolicyReturnsOnCall[i] = struct {
		result1 *v1alpha1.EvaluatePolicyResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeManager) GetPolicy(arg1 context.Context, arg2 *v1alpha1.GetPolicyRequest) (*v1alpha1.Policy, error) {
	fake.getPolicyMutex.Lock()
	ret, specificReturn := fake.getPolicyReturnsOnCall[len(fake.getPolicyArgsForCall)]
	fake.getPolicyArgsForCall = append(fake.getPolicyArgsForCall, struct {
		arg1 context.Context
		arg2 *v1alpha1.GetPolicyRequest
	}{arg1, arg2})
	stub := fake.GetPolicyStub
	fakeReturns := fake.getPolicyReturns
	fake.recordInvocation("GetPolicy", []interface{}{arg1, arg2})
	fake.getPolicyMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeManager) GetPolicyCallCount() int {
	fake.getPolicyMutex.RLock()
	defer fake.getPolicyMutex.RUnlock()
	return len(fake.getPolicyArgsForCall)
}

func (fake *FakeManager) GetPolicyCalls(stub func(context.Context, *v1alpha1.GetPolicyRequest) (*v1alpha1.Policy, error)) {
	fake.getPolicyMutex.Lock()
	defer fake.getPolicyMutex.Unlock()
	fake.GetPolicyStub = stub
}

func (fake *FakeManager) GetPolicyArgsForCall(i int) (context.Context, *v1alpha1.GetPolicyRequest) {
	fake.getPolicyMutex.RLock()
	defer fake.getPolicyMutex.RUnlock()
	argsForCall := fake.getPolicyArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeManager) GetPolicyReturns(result1 *v1alpha1.Policy, result2 error) {
	fake.getPolicyMutex.Lock()
	defer fake.getPolicyMutex.Unlock()
	fake.GetPolicyStub = nil
	fake.getPolicyReturns = struct {
		result1 *v1alpha1.Policy
		result2 error
	}{result1, result2}
}

func (fake *FakeManager) GetPolicyReturnsOnCall(i int, result1 *v1alpha1.Policy, result2 error) {
	fake.getPolicyMutex.Lock()
	defer fake.getPolicyMutex.Unlock()
	fake.GetPolicyStub = nil
	if fake.getPolicyReturnsOnCall == nil {
		fake.getPolicyReturnsOnCall = make(map[int]struct {
			result1 *v1alpha1.Policy
			result2 error
		})
	}
	fake.getPolicyReturnsOnCall[i] = struct {
		result1 *v1alpha1.Policy
		result2 error
	}{result1, result2}
}

func (fake *FakeManager) ListPolicies(arg1 context.Context, arg2 *v1alpha1.ListPoliciesRequest) (*v1alpha1.ListPoliciesResponse, error) {
	fake.listPoliciesMutex.Lock()
	ret, specificReturn := fake.listPoliciesReturnsOnCall[len(fake.listPoliciesArgsForCall)]
	fake.listPoliciesArgsForCall = append(fake.listPoliciesArgsForCall, struct {
		arg1 context.Context
		arg2 *v1alpha1.ListPoliciesRequest
	}{arg1, arg2})
	stub := fake.ListPoliciesStub
	fakeReturns := fake.listPoliciesReturns
	fake.recordInvocation("ListPolicies", []interface{}{arg1, arg2})
	fake.listPoliciesMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeManager) ListPoliciesCallCount() int {
	fake.listPoliciesMutex.RLock()
	defer fake.listPoliciesMutex.RUnlock()
	return len(fake.listPoliciesArgsForCall)
}

func (fake *FakeManager) ListPoliciesCalls(stub func(context.Context, *v1alpha1.ListPoliciesRequest) (*v1alpha1.ListPoliciesResponse, error)) {
	fake.listPoliciesMutex.Lock()
	defer fake.listPoliciesMutex.Unlock()
	fake.ListPoliciesStub = stub
}

func (fake *FakeManager) ListPoliciesArgsForCall(i int) (context.Context, *v1alpha1.ListPoliciesRequest) {
	fake.listPoliciesMutex.RLock()
	defer fake.listPoliciesMutex.RUnlock()
	argsForCall := fake.listPoliciesArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeManager) ListPoliciesReturns(result1 *v1alpha1.ListPoliciesResponse, result2 error) {
	fake.listPoliciesMutex.Lock()
	defer fake.listPoliciesMutex.Unlock()
	fake.ListPoliciesStub = nil
	fake.listPoliciesReturns = struct {
		result1 *v1alpha1.ListPoliciesResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeManager) ListPoliciesReturnsOnCall(i int, result1 *v1alpha1.ListPoliciesResponse, result2 error) {
	fake.listPoliciesMutex.Lock()
	defer fake.listPoliciesMutex.Unlock()
	fake.ListPoliciesStub = nil
	if fake.listPoliciesReturnsOnCall == nil {
		fake.listPoliciesReturnsOnCall = make(map[int]struct {
			result1 *v1alpha1.ListPoliciesResponse
			result2 error
		})
	}
	fake.listPoliciesReturnsOnCall[i] = struct {
		result1 *v1alpha1.ListPoliciesResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeManager) ListPolicyVersions(arg1 context.Context, arg2 *v1alpha1.ListPolicyVersionsRequest) (*v1alpha1.ListPolicyVersionsResponse, error) {
	fake.listPolicyVersionsMutex.Lock()
	ret, specificReturn := fake.listPolicyVersionsReturnsOnCall[len(fake.listPolicyVersionsArgsForCall)]
	fake.listPolicyVersionsArgsForCall = append(fake.listPolicyVersionsArgsForCall, struct {
		arg1 context.Context
		arg2 *v1alpha1.ListPolicyVersionsRequest
	}{arg1, arg2})
	stub := fake.ListPolicyVersionsStub
	fakeReturns := fake.listPolicyVersionsReturns
	fake.recordInvocation("ListPolicyVersions", []interface{}{arg1, arg2})
	fake.listPolicyVersionsMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeManager) ListPolicyVersionsCallCount() int {
	fake.listPolicyVersionsMutex.RLock()
	defer fake.listPolicyVersionsMutex.RUnlock()
	return len(fake.listPolicyVersionsArgsForCall)
}

func (fake *FakeManager) ListPolicyVersionsCalls(stub func(context.Context, *v1alpha1.ListPolicyVersionsRequest) (*v1alpha1.ListPolicyVersionsResponse, error)) {
	fake.listPolicyVersionsMutex.Lock()
	defer fake.listPolicyVersionsMutex.Unlock()
	fake.ListPolicyVersionsStub = stub
}

func (fake *FakeManager) ListPolicyVersionsArgsForCall(i int) (context.Context, *v1alpha1.ListPolicyVersionsRequest) {
	fake.listPolicyVersionsMutex.RLock()
	defer fake.listPolicyVersionsMutex.RUnlock()
	argsForCall := fake.listPolicyVersionsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeManager) ListPolicyVersionsReturns(result1 *v1alpha1.ListPolicyVersionsResponse, result2 error) {
	fake.listPolicyVersionsMutex.Lock()
	defer fake.listPolicyVersionsMutex.Unlock()
	fake.ListPolicyVersionsStub = nil
	fake.listPolicyVersionsReturns = struct {
		result1 *v1alpha1.ListPolicyVersionsResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeManager) ListPolicyVersionsReturnsOnCall(i int, result1 *v1alpha1.ListPolicyVersionsResponse, result2 error) {
	fake.listPolicyVersionsMutex.Lock()
	defer fake.listPolicyVersionsMutex.Unlock()
	fake.ListPolicyVersionsStub = nil
	if fake.listPolicyVersionsReturnsOnCall == nil {
		fake.listPolicyVersionsReturnsOnCall = make(map[int]struct {
			result1 *v1alpha1.ListPolicyVersionsResponse
			result2 error
		})
	}
	fake.listPolicyVersionsReturnsOnCall[i] = struct {
		result1 *v1alpha1.ListPolicyVersionsResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeManager) UpdatePolicy(arg1 context.Context, arg2 *v1alpha1.UpdatePolicyRequest) (*v1alpha1.Policy, error) {
	fake.updatePolicyMutex.Lock()
	ret, specificReturn := fake.updatePolicyReturnsOnCall[len(fake.updatePolicyArgsForCall)]
	fake.updatePolicyArgsForCall = append(fake.updatePolicyArgsForCall, struct {
		arg1 context.Context
		arg2 *v1alpha1.UpdatePolicyRequest
	}{arg1, arg2})
	stub := fake.UpdatePolicyStub
	fakeReturns := fake.updatePolicyReturns
	fake.recordInvocation("UpdatePolicy", []interface{}{arg1, arg2})
	fake.updatePolicyMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeManager) UpdatePolicyCallCount() int {
	fake.updatePolicyMutex.RLock()
	defer fake.updatePolicyMutex.RUnlock()
	return len(fake.updatePolicyArgsForCall)
}

func (fake *FakeManager) UpdatePolicyCalls(stub func(context.Context, *v1alpha1.UpdatePolicyRequest) (*v1alpha1.Policy, error)) {
	fake.updatePolicyMutex.Lock()
	defer fake.updatePolicyMutex.Unlock()
	fake.UpdatePolicyStub = stub
}

func (fake *FakeManager) UpdatePolicyArgsForCall(i int) (context.Context, *v1alpha1.UpdatePolicyRequest) {
	fake.updatePolicyMutex.RLock()
	defer fake.updatePolicyMutex.RUnlock()
	argsForCall := fake.updatePolicyArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeManager) UpdatePolicyReturns(result1 *v1alpha1.Policy, result2 error) {
	fake.updatePolicyMutex.Lock()
	defer fake.updatePolicyMutex.Unlock()
	fake.UpdatePolicyStub = nil
	fake.updatePolicyReturns = struct {
		result1 *v1alpha1.Policy
		result2 error
	}{result1, result2}
}

func (fake *FakeManager) UpdatePolicyReturnsOnCall(i int, result1 *v1alpha1.Policy, result2 error) {
	fake.updatePolicyMutex.Lock()
	defer fake.updatePolicyMutex.Unlock()
	fake.UpdatePolicyStub = nil
	if fake.updatePolicyReturnsOnCall == nil {
		fake.updatePolicyReturnsOnCall = make(map[int]struct {
			result1 *v1alpha1.Policy
			result2 error
		})
	}
	fake.updatePolicyReturnsOnCall[i] = struct {
		result1 *v1alpha1.Policy
		result2 error
	}{result1, result2}
}

func (fake *FakeManager) ValidatePolicy(arg1 context.Context, arg2 *v1alpha1.ValidatePolicyRequest) (*v1alpha1.ValidatePolicyResponse, error) {
	fake.validatePolicyMutex.Lock()
	ret, specificReturn := fake.validatePolicyReturnsOnCall[len(fake.validatePolicyArgsForCall)]
	fake.validatePolicyArgsForCall = append(fake.validatePolicyArgsForCall, struct {
		arg1 context.Context
		arg2 *v1alpha1.ValidatePolicyRequest
	}{arg1, arg2})
	stub := fake.ValidatePolicyStub
	fakeReturns := fake.validatePolicyReturns
	fake.recordInvocation("ValidatePolicy", []interface{}{arg1, arg2})
	fake.validatePolicyMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeManager) ValidatePolicyCallCount() int {
	fake.validatePolicyMutex.RLock()
	defer fake.validatePolicyMutex.RUnlock()
	return len(fake.validatePolicyArgsForCall)
}

func (fake *FakeManager) ValidatePolicyCalls(stub func(context.Context, *v1alpha1.ValidatePolicyRequest) (*v1alpha1.ValidatePolicyResponse, error)) {
	fake.validatePolicyMutex.Lock()
	defer fake.validatePolicyMutex.Unlock()
	fake.ValidatePolicyStub = stub
}

func (fake *FakeManager) ValidatePolicyArgsForCall(i int) (context.Context, *v1alpha1.ValidatePolicyRequest) {
	fake.validatePolicyMutex.RLock()
	defer fake.validatePolicyMutex.RUnlock()
	argsForCall := fake.validatePolicyArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeManager) ValidatePolicyReturns(result1 *v1alpha1.ValidatePolicyResponse, result2 error) {
	fake.validatePolicyMutex.Lock()
	defer fake.validatePolicyMutex.Unlock()
	fake.ValidatePolicyStub = nil
	fake.validatePolicyReturns = struct {
		result1 *v1alpha1.ValidatePolicyResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeManager) ValidatePolicyReturnsOnCall(i int, result1 *v1alpha1.ValidatePolicyResponse, result2 error) {
	fake.validatePolicyMutex.Lock()
	defer fake.validatePolicyMutex.Unlock()
	fake.ValidatePolicyStub = nil
	if fake.validatePolicyReturnsOnCall == nil {
		fake.validatePolicyReturnsOnCall = make(map[int]struct {
			result1 *v1alpha1.ValidatePolicyResponse
			result2 error
		})
	}
	fake.validatePolicyReturnsOnCall[i] = struct {
		result1 *v1alpha1.ValidatePolicyResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeManager) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.createPolicyMutex.RLock()
	defer fake.createPolicyMutex.RUnlock()
	fake.deletePolicyMutex.RLock()
	defer fake.deletePolicyMutex.RUnlock()
	fake.evaluatePolicyMutex.RLock()
	defer fake.evaluatePolicyMutex.RUnlock()
	fake.getPolicyMutex.RLock()
	defer fake.getPolicyMutex.RUnlock()
	fake.listPoliciesMutex.RLock()
	defer fake.listPoliciesMutex.RUnlock()
	fake.listPolicyVersionsMutex.RLock()
	defer fake.listPolicyVersionsMutex.RUnlock()
	fake.updatePolicyMutex.RLock()
	defer fake.updatePolicyMutex.RUnlock()
	fake.validatePolicyMutex.RLock()
	defer fake.validatePolicyMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeManager) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ policy.Manager = new(FakeManager)
